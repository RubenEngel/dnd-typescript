/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
/******/ (() => { // webpackBootstrap
/******/ 	"use strict";
/******/ 	var __webpack_modules__ = ({

/***/ "./node_modules/pointer-tracker/dist/PointerTracker.mjs":
/*!**************************************************************!*\
  !*** ./node_modules/pointer-tracker/dist/PointerTracker.mjs ***!
  \**************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\nclass Pointer {\r\n    constructor(nativePointer) {\r\n        /** Unique ID for this pointer */\r\n        this.id = -1;\r\n        this.nativePointer = nativePointer;\r\n        this.pageX = nativePointer.pageX;\r\n        this.pageY = nativePointer.pageY;\r\n        this.clientX = nativePointer.clientX;\r\n        this.clientY = nativePointer.clientY;\r\n        if (self.Touch && nativePointer instanceof Touch) {\r\n            this.id = nativePointer.identifier;\r\n        }\r\n        else if (isPointerEvent(nativePointer)) {\r\n            // is PointerEvent\r\n            this.id = nativePointer.pointerId;\r\n        }\r\n    }\r\n    /**\r\n     * Returns an expanded set of Pointers for high-resolution inputs.\r\n     */\r\n    getCoalesced() {\r\n        if ('getCoalescedEvents' in this.nativePointer) {\r\n            return this.nativePointer.getCoalescedEvents().map((p) => new Pointer(p));\r\n        }\r\n        return [this];\r\n    }\r\n}\r\nconst isPointerEvent = (event) => self.PointerEvent && event instanceof PointerEvent;\r\nconst noop = () => { };\r\n/**\r\n * Track pointers across a particular element\r\n */\r\nclass PointerTracker {\r\n    /**\r\n     * Track pointers across a particular element\r\n     *\r\n     * @param element Element to monitor.\r\n     * @param options\r\n     */\r\n    constructor(_element, { start = () => true, move = noop, end = noop, rawUpdates = false, } = {}) {\r\n        this._element = _element;\r\n        /**\r\n         * State of the tracked pointers when they were pressed/touched.\r\n         */\r\n        this.startPointers = [];\r\n        /**\r\n         * Latest state of the tracked pointers. Contains the same number of pointers, and in the same\r\n         * order as this.startPointers.\r\n         */\r\n        this.currentPointers = [];\r\n        /**\r\n         * Listener for mouse/pointer starts.\r\n         *\r\n         * @param event This will only be a MouseEvent if the browser doesn't support pointer events.\r\n         */\r\n        this._pointerStart = (event) => {\r\n            if (event.button !== 0 /* Left */)\r\n                return;\r\n            if (!this._triggerPointerStart(new Pointer(event), event))\r\n                return;\r\n            // Add listeners for additional events.\r\n            // The listeners may already exist, but no harm in adding them again.\r\n            if (isPointerEvent(event)) {\r\n                const capturingElement = event.target && 'setPointerCapture' in event.target\r\n                    ? event.target\r\n                    : this._element;\r\n                capturingElement.setPointerCapture(event.pointerId);\r\n                this._element.addEventListener(this._rawUpdates ? 'pointerrawupdate' : 'pointermove', this._move);\r\n                this._element.addEventListener('pointerup', this._pointerEnd);\r\n                this._element.addEventListener('pointercancel', this._pointerEnd);\r\n            }\r\n            else {\r\n                // MouseEvent\r\n                window.addEventListener('mousemove', this._move);\r\n                window.addEventListener('mouseup', this._pointerEnd);\r\n            }\r\n        };\r\n        /**\r\n         * Listener for touchstart.\r\n         * Only used if the browser doesn't support pointer events.\r\n         */\r\n        this._touchStart = (event) => {\r\n            for (const touch of Array.from(event.changedTouches)) {\r\n                this._triggerPointerStart(new Pointer(touch), event);\r\n            }\r\n        };\r\n        /**\r\n         * Listener for pointer/mouse/touch move events.\r\n         */\r\n        this._move = (event) => {\r\n            const previousPointers = this.currentPointers.slice();\r\n            const changedPointers = 'changedTouches' in event // Shortcut for 'is touch event'.\r\n                ? Array.from(event.changedTouches).map((t) => new Pointer(t))\r\n                : [new Pointer(event)];\r\n            const trackedChangedPointers = [];\r\n            for (const pointer of changedPointers) {\r\n                const index = this.currentPointers.findIndex((p) => p.id === pointer.id);\r\n                if (index === -1)\r\n                    continue; // Not a pointer we're tracking\r\n                trackedChangedPointers.push(pointer);\r\n                this.currentPointers[index] = pointer;\r\n            }\r\n            if (trackedChangedPointers.length === 0)\r\n                return;\r\n            this._moveCallback(previousPointers, trackedChangedPointers, event);\r\n        };\r\n        /**\r\n         * Call the end callback for this pointer.\r\n         *\r\n         * @param pointer Pointer\r\n         * @param event Related event\r\n         */\r\n        this._triggerPointerEnd = (pointer, event) => {\r\n            const index = this.currentPointers.findIndex((p) => p.id === pointer.id);\r\n            // Not a pointer we're interested in?\r\n            if (index === -1)\r\n                return false;\r\n            this.currentPointers.splice(index, 1);\r\n            this.startPointers.splice(index, 1);\r\n            const cancelled = event.type === 'touchcancel' || event.type === 'pointercancel';\r\n            this._endCallback(pointer, event, cancelled);\r\n            return true;\r\n        };\r\n        /**\r\n         * Listener for mouse/pointer ends.\r\n         *\r\n         * @param event This will only be a MouseEvent if the browser doesn't support pointer events.\r\n         */\r\n        this._pointerEnd = (event) => {\r\n            if (!this._triggerPointerEnd(new Pointer(event), event))\r\n                return;\r\n            if (isPointerEvent(event)) {\r\n                if (this.currentPointers.length)\r\n                    return;\r\n                this._element.removeEventListener(this._rawUpdates ? 'pointerrawupdate' : 'pointermove', this._move);\r\n                this._element.removeEventListener('pointerup', this._pointerEnd);\r\n                this._element.removeEventListener('pointercancel', this._pointerEnd);\r\n            }\r\n            else {\r\n                // MouseEvent\r\n                window.removeEventListener('mousemove', this._move);\r\n                window.removeEventListener('mouseup', this._pointerEnd);\r\n            }\r\n        };\r\n        /**\r\n         * Listener for touchend.\r\n         * Only used if the browser doesn't support pointer events.\r\n         */\r\n        this._touchEnd = (event) => {\r\n            for (const touch of Array.from(event.changedTouches)) {\r\n                this._triggerPointerEnd(new Pointer(touch), event);\r\n            }\r\n        };\r\n        this._startCallback = start;\r\n        this._moveCallback = move;\r\n        this._endCallback = end;\r\n        this._rawUpdates = rawUpdates && 'onpointerrawupdate' in window;\r\n        // Add listeners\r\n        if (self.PointerEvent) {\r\n            this._element.addEventListener('pointerdown', this._pointerStart);\r\n        }\r\n        else {\r\n            this._element.addEventListener('mousedown', this._pointerStart);\r\n            this._element.addEventListener('touchstart', this._touchStart);\r\n            this._element.addEventListener('touchmove', this._move);\r\n            this._element.addEventListener('touchend', this._touchEnd);\r\n            this._element.addEventListener('touchcancel', this._touchEnd);\r\n        }\r\n    }\r\n    /**\r\n     * Remove all listeners.\r\n     */\r\n    stop() {\r\n        this._element.removeEventListener('pointerdown', this._pointerStart);\r\n        this._element.removeEventListener('mousedown', this._pointerStart);\r\n        this._element.removeEventListener('touchstart', this._touchStart);\r\n        this._element.removeEventListener('touchmove', this._move);\r\n        this._element.removeEventListener('touchend', this._touchEnd);\r\n        this._element.removeEventListener('touchcancel', this._touchEnd);\r\n        this._element.removeEventListener(this._rawUpdates ? 'pointerrawupdate' : 'pointermove', this._move);\r\n        this._element.removeEventListener('pointerup', this._pointerEnd);\r\n        this._element.removeEventListener('pointercancel', this._pointerEnd);\r\n        window.removeEventListener('mousemove', this._move);\r\n        window.removeEventListener('mouseup', this._pointerEnd);\r\n    }\r\n    /**\r\n     * Call the start callback for this pointer, and track it if the user wants.\r\n     *\r\n     * @param pointer Pointer\r\n     * @param event Related event\r\n     * @returns Whether the pointer is being tracked.\r\n     */\r\n    _triggerPointerStart(pointer, event) {\r\n        if (!this._startCallback(pointer, event))\r\n            return false;\r\n        this.currentPointers.push(pointer);\r\n        this.startPointers.push(pointer);\r\n        return true;\r\n    }\r\n}\n\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (PointerTracker);\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9kbmQtdHlwZXNjcmlwdC8uL25vZGVfbW9kdWxlcy9wb2ludGVyLXRyYWNrZXIvZGlzdC9Qb2ludGVyVHJhY2tlci5tanM/YWI1NiJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiOzs7O0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0I7QUFDcEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQkFBMkIsbUVBQW1FLEtBQUs7QUFDbkc7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2QkFBNkI7QUFDN0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxpRUFBZSxjQUFjLEVBQUMiLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvcG9pbnRlci10cmFja2VyL2Rpc3QvUG9pbnRlclRyYWNrZXIubWpzLmpzIiwic291cmNlc0NvbnRlbnQiOlsiY2xhc3MgUG9pbnRlciB7XHJcbiAgICBjb25zdHJ1Y3RvcihuYXRpdmVQb2ludGVyKSB7XHJcbiAgICAgICAgLyoqIFVuaXF1ZSBJRCBmb3IgdGhpcyBwb2ludGVyICovXHJcbiAgICAgICAgdGhpcy5pZCA9IC0xO1xyXG4gICAgICAgIHRoaXMubmF0aXZlUG9pbnRlciA9IG5hdGl2ZVBvaW50ZXI7XHJcbiAgICAgICAgdGhpcy5wYWdlWCA9IG5hdGl2ZVBvaW50ZXIucGFnZVg7XHJcbiAgICAgICAgdGhpcy5wYWdlWSA9IG5hdGl2ZVBvaW50ZXIucGFnZVk7XHJcbiAgICAgICAgdGhpcy5jbGllbnRYID0gbmF0aXZlUG9pbnRlci5jbGllbnRYO1xyXG4gICAgICAgIHRoaXMuY2xpZW50WSA9IG5hdGl2ZVBvaW50ZXIuY2xpZW50WTtcclxuICAgICAgICBpZiAoc2VsZi5Ub3VjaCAmJiBuYXRpdmVQb2ludGVyIGluc3RhbmNlb2YgVG91Y2gpIHtcclxuICAgICAgICAgICAgdGhpcy5pZCA9IG5hdGl2ZVBvaW50ZXIuaWRlbnRpZmllcjtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSBpZiAoaXNQb2ludGVyRXZlbnQobmF0aXZlUG9pbnRlcikpIHtcclxuICAgICAgICAgICAgLy8gaXMgUG9pbnRlckV2ZW50XHJcbiAgICAgICAgICAgIHRoaXMuaWQgPSBuYXRpdmVQb2ludGVyLnBvaW50ZXJJZDtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIFJldHVybnMgYW4gZXhwYW5kZWQgc2V0IG9mIFBvaW50ZXJzIGZvciBoaWdoLXJlc29sdXRpb24gaW5wdXRzLlxyXG4gICAgICovXHJcbiAgICBnZXRDb2FsZXNjZWQoKSB7XHJcbiAgICAgICAgaWYgKCdnZXRDb2FsZXNjZWRFdmVudHMnIGluIHRoaXMubmF0aXZlUG9pbnRlcikge1xyXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5uYXRpdmVQb2ludGVyLmdldENvYWxlc2NlZEV2ZW50cygpLm1hcCgocCkgPT4gbmV3IFBvaW50ZXIocCkpO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gW3RoaXNdO1xyXG4gICAgfVxyXG59XHJcbmNvbnN0IGlzUG9pbnRlckV2ZW50ID0gKGV2ZW50KSA9PiBzZWxmLlBvaW50ZXJFdmVudCAmJiBldmVudCBpbnN0YW5jZW9mIFBvaW50ZXJFdmVudDtcclxuY29uc3Qgbm9vcCA9ICgpID0+IHsgfTtcclxuLyoqXHJcbiAqIFRyYWNrIHBvaW50ZXJzIGFjcm9zcyBhIHBhcnRpY3VsYXIgZWxlbWVudFxyXG4gKi9cclxuY2xhc3MgUG9pbnRlclRyYWNrZXIge1xyXG4gICAgLyoqXHJcbiAgICAgKiBUcmFjayBwb2ludGVycyBhY3Jvc3MgYSBwYXJ0aWN1bGFyIGVsZW1lbnRcclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0gZWxlbWVudCBFbGVtZW50IHRvIG1vbml0b3IuXHJcbiAgICAgKiBAcGFyYW0gb3B0aW9uc1xyXG4gICAgICovXHJcbiAgICBjb25zdHJ1Y3RvcihfZWxlbWVudCwgeyBzdGFydCA9ICgpID0+IHRydWUsIG1vdmUgPSBub29wLCBlbmQgPSBub29wLCByYXdVcGRhdGVzID0gZmFsc2UsIH0gPSB7fSkge1xyXG4gICAgICAgIHRoaXMuX2VsZW1lbnQgPSBfZWxlbWVudDtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBTdGF0ZSBvZiB0aGUgdHJhY2tlZCBwb2ludGVycyB3aGVuIHRoZXkgd2VyZSBwcmVzc2VkL3RvdWNoZWQuXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgdGhpcy5zdGFydFBvaW50ZXJzID0gW107XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogTGF0ZXN0IHN0YXRlIG9mIHRoZSB0cmFja2VkIHBvaW50ZXJzLiBDb250YWlucyB0aGUgc2FtZSBudW1iZXIgb2YgcG9pbnRlcnMsIGFuZCBpbiB0aGUgc2FtZVxyXG4gICAgICAgICAqIG9yZGVyIGFzIHRoaXMuc3RhcnRQb2ludGVycy5cclxuICAgICAgICAgKi9cclxuICAgICAgICB0aGlzLmN1cnJlbnRQb2ludGVycyA9IFtdO1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIExpc3RlbmVyIGZvciBtb3VzZS9wb2ludGVyIHN0YXJ0cy5cclxuICAgICAgICAgKlxyXG4gICAgICAgICAqIEBwYXJhbSBldmVudCBUaGlzIHdpbGwgb25seSBiZSBhIE1vdXNlRXZlbnQgaWYgdGhlIGJyb3dzZXIgZG9lc24ndCBzdXBwb3J0IHBvaW50ZXIgZXZlbnRzLlxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIHRoaXMuX3BvaW50ZXJTdGFydCA9IChldmVudCkgPT4ge1xyXG4gICAgICAgICAgICBpZiAoZXZlbnQuYnV0dG9uICE9PSAwIC8qIExlZnQgKi8pXHJcbiAgICAgICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgICAgIGlmICghdGhpcy5fdHJpZ2dlclBvaW50ZXJTdGFydChuZXcgUG9pbnRlcihldmVudCksIGV2ZW50KSlcclxuICAgICAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICAgICAgLy8gQWRkIGxpc3RlbmVycyBmb3IgYWRkaXRpb25hbCBldmVudHMuXHJcbiAgICAgICAgICAgIC8vIFRoZSBsaXN0ZW5lcnMgbWF5IGFscmVhZHkgZXhpc3QsIGJ1dCBubyBoYXJtIGluIGFkZGluZyB0aGVtIGFnYWluLlxyXG4gICAgICAgICAgICBpZiAoaXNQb2ludGVyRXZlbnQoZXZlbnQpKSB7XHJcbiAgICAgICAgICAgICAgICBjb25zdCBjYXB0dXJpbmdFbGVtZW50ID0gZXZlbnQudGFyZ2V0ICYmICdzZXRQb2ludGVyQ2FwdHVyZScgaW4gZXZlbnQudGFyZ2V0XHJcbiAgICAgICAgICAgICAgICAgICAgPyBldmVudC50YXJnZXRcclxuICAgICAgICAgICAgICAgICAgICA6IHRoaXMuX2VsZW1lbnQ7XHJcbiAgICAgICAgICAgICAgICBjYXB0dXJpbmdFbGVtZW50LnNldFBvaW50ZXJDYXB0dXJlKGV2ZW50LnBvaW50ZXJJZCk7XHJcbiAgICAgICAgICAgICAgICB0aGlzLl9lbGVtZW50LmFkZEV2ZW50TGlzdGVuZXIodGhpcy5fcmF3VXBkYXRlcyA/ICdwb2ludGVycmF3dXBkYXRlJyA6ICdwb2ludGVybW92ZScsIHRoaXMuX21vdmUpO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5fZWxlbWVudC5hZGRFdmVudExpc3RlbmVyKCdwb2ludGVydXAnLCB0aGlzLl9wb2ludGVyRW5kKTtcclxuICAgICAgICAgICAgICAgIHRoaXMuX2VsZW1lbnQuYWRkRXZlbnRMaXN0ZW5lcigncG9pbnRlcmNhbmNlbCcsIHRoaXMuX3BvaW50ZXJFbmQpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgLy8gTW91c2VFdmVudFxyXG4gICAgICAgICAgICAgICAgd2luZG93LmFkZEV2ZW50TGlzdGVuZXIoJ21vdXNlbW92ZScsIHRoaXMuX21vdmUpO1xyXG4gICAgICAgICAgICAgICAgd2luZG93LmFkZEV2ZW50TGlzdGVuZXIoJ21vdXNldXAnLCB0aGlzLl9wb2ludGVyRW5kKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH07XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogTGlzdGVuZXIgZm9yIHRvdWNoc3RhcnQuXHJcbiAgICAgICAgICogT25seSB1c2VkIGlmIHRoZSBicm93c2VyIGRvZXNuJ3Qgc3VwcG9ydCBwb2ludGVyIGV2ZW50cy5cclxuICAgICAgICAgKi9cclxuICAgICAgICB0aGlzLl90b3VjaFN0YXJ0ID0gKGV2ZW50KSA9PiB7XHJcbiAgICAgICAgICAgIGZvciAoY29uc3QgdG91Y2ggb2YgQXJyYXkuZnJvbShldmVudC5jaGFuZ2VkVG91Y2hlcykpIHtcclxuICAgICAgICAgICAgICAgIHRoaXMuX3RyaWdnZXJQb2ludGVyU3RhcnQobmV3IFBvaW50ZXIodG91Y2gpLCBldmVudCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9O1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIExpc3RlbmVyIGZvciBwb2ludGVyL21vdXNlL3RvdWNoIG1vdmUgZXZlbnRzLlxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIHRoaXMuX21vdmUgPSAoZXZlbnQpID0+IHtcclxuICAgICAgICAgICAgY29uc3QgcHJldmlvdXNQb2ludGVycyA9IHRoaXMuY3VycmVudFBvaW50ZXJzLnNsaWNlKCk7XHJcbiAgICAgICAgICAgIGNvbnN0IGNoYW5nZWRQb2ludGVycyA9ICdjaGFuZ2VkVG91Y2hlcycgaW4gZXZlbnQgLy8gU2hvcnRjdXQgZm9yICdpcyB0b3VjaCBldmVudCcuXHJcbiAgICAgICAgICAgICAgICA/IEFycmF5LmZyb20oZXZlbnQuY2hhbmdlZFRvdWNoZXMpLm1hcCgodCkgPT4gbmV3IFBvaW50ZXIodCkpXHJcbiAgICAgICAgICAgICAgICA6IFtuZXcgUG9pbnRlcihldmVudCldO1xyXG4gICAgICAgICAgICBjb25zdCB0cmFja2VkQ2hhbmdlZFBvaW50ZXJzID0gW107XHJcbiAgICAgICAgICAgIGZvciAoY29uc3QgcG9pbnRlciBvZiBjaGFuZ2VkUG9pbnRlcnMpIHtcclxuICAgICAgICAgICAgICAgIGNvbnN0IGluZGV4ID0gdGhpcy5jdXJyZW50UG9pbnRlcnMuZmluZEluZGV4KChwKSA9PiBwLmlkID09PSBwb2ludGVyLmlkKTtcclxuICAgICAgICAgICAgICAgIGlmIChpbmRleCA9PT0gLTEpXHJcbiAgICAgICAgICAgICAgICAgICAgY29udGludWU7IC8vIE5vdCBhIHBvaW50ZXIgd2UncmUgdHJhY2tpbmdcclxuICAgICAgICAgICAgICAgIHRyYWNrZWRDaGFuZ2VkUG9pbnRlcnMucHVzaChwb2ludGVyKTtcclxuICAgICAgICAgICAgICAgIHRoaXMuY3VycmVudFBvaW50ZXJzW2luZGV4XSA9IHBvaW50ZXI7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgaWYgKHRyYWNrZWRDaGFuZ2VkUG9pbnRlcnMubGVuZ3RoID09PSAwKVxyXG4gICAgICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgICAgICB0aGlzLl9tb3ZlQ2FsbGJhY2socHJldmlvdXNQb2ludGVycywgdHJhY2tlZENoYW5nZWRQb2ludGVycywgZXZlbnQpO1xyXG4gICAgICAgIH07XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogQ2FsbCB0aGUgZW5kIGNhbGxiYWNrIGZvciB0aGlzIHBvaW50ZXIuXHJcbiAgICAgICAgICpcclxuICAgICAgICAgKiBAcGFyYW0gcG9pbnRlciBQb2ludGVyXHJcbiAgICAgICAgICogQHBhcmFtIGV2ZW50IFJlbGF0ZWQgZXZlbnRcclxuICAgICAgICAgKi9cclxuICAgICAgICB0aGlzLl90cmlnZ2VyUG9pbnRlckVuZCA9IChwb2ludGVyLCBldmVudCkgPT4ge1xyXG4gICAgICAgICAgICBjb25zdCBpbmRleCA9IHRoaXMuY3VycmVudFBvaW50ZXJzLmZpbmRJbmRleCgocCkgPT4gcC5pZCA9PT0gcG9pbnRlci5pZCk7XHJcbiAgICAgICAgICAgIC8vIE5vdCBhIHBvaW50ZXIgd2UncmUgaW50ZXJlc3RlZCBpbj9cclxuICAgICAgICAgICAgaWYgKGluZGV4ID09PSAtMSlcclxuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgICAgICAgICAgdGhpcy5jdXJyZW50UG9pbnRlcnMuc3BsaWNlKGluZGV4LCAxKTtcclxuICAgICAgICAgICAgdGhpcy5zdGFydFBvaW50ZXJzLnNwbGljZShpbmRleCwgMSk7XHJcbiAgICAgICAgICAgIGNvbnN0IGNhbmNlbGxlZCA9IGV2ZW50LnR5cGUgPT09ICd0b3VjaGNhbmNlbCcgfHwgZXZlbnQudHlwZSA9PT0gJ3BvaW50ZXJjYW5jZWwnO1xyXG4gICAgICAgICAgICB0aGlzLl9lbmRDYWxsYmFjayhwb2ludGVyLCBldmVudCwgY2FuY2VsbGVkKTtcclxuICAgICAgICAgICAgcmV0dXJuIHRydWU7XHJcbiAgICAgICAgfTtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBMaXN0ZW5lciBmb3IgbW91c2UvcG9pbnRlciBlbmRzLlxyXG4gICAgICAgICAqXHJcbiAgICAgICAgICogQHBhcmFtIGV2ZW50IFRoaXMgd2lsbCBvbmx5IGJlIGEgTW91c2VFdmVudCBpZiB0aGUgYnJvd3NlciBkb2Vzbid0IHN1cHBvcnQgcG9pbnRlciBldmVudHMuXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgdGhpcy5fcG9pbnRlckVuZCA9IChldmVudCkgPT4ge1xyXG4gICAgICAgICAgICBpZiAoIXRoaXMuX3RyaWdnZXJQb2ludGVyRW5kKG5ldyBQb2ludGVyKGV2ZW50KSwgZXZlbnQpKVxyXG4gICAgICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgICAgICBpZiAoaXNQb2ludGVyRXZlbnQoZXZlbnQpKSB7XHJcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5jdXJyZW50UG9pbnRlcnMubGVuZ3RoKVxyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICAgICAgICAgIHRoaXMuX2VsZW1lbnQucmVtb3ZlRXZlbnRMaXN0ZW5lcih0aGlzLl9yYXdVcGRhdGVzID8gJ3BvaW50ZXJyYXd1cGRhdGUnIDogJ3BvaW50ZXJtb3ZlJywgdGhpcy5fbW92ZSk7XHJcbiAgICAgICAgICAgICAgICB0aGlzLl9lbGVtZW50LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ3BvaW50ZXJ1cCcsIHRoaXMuX3BvaW50ZXJFbmQpO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5fZWxlbWVudC5yZW1vdmVFdmVudExpc3RlbmVyKCdwb2ludGVyY2FuY2VsJywgdGhpcy5fcG9pbnRlckVuZCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAvLyBNb3VzZUV2ZW50XHJcbiAgICAgICAgICAgICAgICB3aW5kb3cucmVtb3ZlRXZlbnRMaXN0ZW5lcignbW91c2Vtb3ZlJywgdGhpcy5fbW92ZSk7XHJcbiAgICAgICAgICAgICAgICB3aW5kb3cucmVtb3ZlRXZlbnRMaXN0ZW5lcignbW91c2V1cCcsIHRoaXMuX3BvaW50ZXJFbmQpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfTtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBMaXN0ZW5lciBmb3IgdG91Y2hlbmQuXHJcbiAgICAgICAgICogT25seSB1c2VkIGlmIHRoZSBicm93c2VyIGRvZXNuJ3Qgc3VwcG9ydCBwb2ludGVyIGV2ZW50cy5cclxuICAgICAgICAgKi9cclxuICAgICAgICB0aGlzLl90b3VjaEVuZCA9IChldmVudCkgPT4ge1xyXG4gICAgICAgICAgICBmb3IgKGNvbnN0IHRvdWNoIG9mIEFycmF5LmZyb20oZXZlbnQuY2hhbmdlZFRvdWNoZXMpKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLl90cmlnZ2VyUG9pbnRlckVuZChuZXcgUG9pbnRlcih0b3VjaCksIGV2ZW50KTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH07XHJcbiAgICAgICAgdGhpcy5fc3RhcnRDYWxsYmFjayA9IHN0YXJ0O1xyXG4gICAgICAgIHRoaXMuX21vdmVDYWxsYmFjayA9IG1vdmU7XHJcbiAgICAgICAgdGhpcy5fZW5kQ2FsbGJhY2sgPSBlbmQ7XHJcbiAgICAgICAgdGhpcy5fcmF3VXBkYXRlcyA9IHJhd1VwZGF0ZXMgJiYgJ29ucG9pbnRlcnJhd3VwZGF0ZScgaW4gd2luZG93O1xyXG4gICAgICAgIC8vIEFkZCBsaXN0ZW5lcnNcclxuICAgICAgICBpZiAoc2VsZi5Qb2ludGVyRXZlbnQpIHtcclxuICAgICAgICAgICAgdGhpcy5fZWxlbWVudC5hZGRFdmVudExpc3RlbmVyKCdwb2ludGVyZG93bicsIHRoaXMuX3BvaW50ZXJTdGFydCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICB0aGlzLl9lbGVtZW50LmFkZEV2ZW50TGlzdGVuZXIoJ21vdXNlZG93bicsIHRoaXMuX3BvaW50ZXJTdGFydCk7XHJcbiAgICAgICAgICAgIHRoaXMuX2VsZW1lbnQuYWRkRXZlbnRMaXN0ZW5lcigndG91Y2hzdGFydCcsIHRoaXMuX3RvdWNoU3RhcnQpO1xyXG4gICAgICAgICAgICB0aGlzLl9lbGVtZW50LmFkZEV2ZW50TGlzdGVuZXIoJ3RvdWNobW92ZScsIHRoaXMuX21vdmUpO1xyXG4gICAgICAgICAgICB0aGlzLl9lbGVtZW50LmFkZEV2ZW50TGlzdGVuZXIoJ3RvdWNoZW5kJywgdGhpcy5fdG91Y2hFbmQpO1xyXG4gICAgICAgICAgICB0aGlzLl9lbGVtZW50LmFkZEV2ZW50TGlzdGVuZXIoJ3RvdWNoY2FuY2VsJywgdGhpcy5fdG91Y2hFbmQpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogUmVtb3ZlIGFsbCBsaXN0ZW5lcnMuXHJcbiAgICAgKi9cclxuICAgIHN0b3AoKSB7XHJcbiAgICAgICAgdGhpcy5fZWxlbWVudC5yZW1vdmVFdmVudExpc3RlbmVyKCdwb2ludGVyZG93bicsIHRoaXMuX3BvaW50ZXJTdGFydCk7XHJcbiAgICAgICAgdGhpcy5fZWxlbWVudC5yZW1vdmVFdmVudExpc3RlbmVyKCdtb3VzZWRvd24nLCB0aGlzLl9wb2ludGVyU3RhcnQpO1xyXG4gICAgICAgIHRoaXMuX2VsZW1lbnQucmVtb3ZlRXZlbnRMaXN0ZW5lcigndG91Y2hzdGFydCcsIHRoaXMuX3RvdWNoU3RhcnQpO1xyXG4gICAgICAgIHRoaXMuX2VsZW1lbnQucmVtb3ZlRXZlbnRMaXN0ZW5lcigndG91Y2htb3ZlJywgdGhpcy5fbW92ZSk7XHJcbiAgICAgICAgdGhpcy5fZWxlbWVudC5yZW1vdmVFdmVudExpc3RlbmVyKCd0b3VjaGVuZCcsIHRoaXMuX3RvdWNoRW5kKTtcclxuICAgICAgICB0aGlzLl9lbGVtZW50LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ3RvdWNoY2FuY2VsJywgdGhpcy5fdG91Y2hFbmQpO1xyXG4gICAgICAgIHRoaXMuX2VsZW1lbnQucmVtb3ZlRXZlbnRMaXN0ZW5lcih0aGlzLl9yYXdVcGRhdGVzID8gJ3BvaW50ZXJyYXd1cGRhdGUnIDogJ3BvaW50ZXJtb3ZlJywgdGhpcy5fbW92ZSk7XHJcbiAgICAgICAgdGhpcy5fZWxlbWVudC5yZW1vdmVFdmVudExpc3RlbmVyKCdwb2ludGVydXAnLCB0aGlzLl9wb2ludGVyRW5kKTtcclxuICAgICAgICB0aGlzLl9lbGVtZW50LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ3BvaW50ZXJjYW5jZWwnLCB0aGlzLl9wb2ludGVyRW5kKTtcclxuICAgICAgICB3aW5kb3cucmVtb3ZlRXZlbnRMaXN0ZW5lcignbW91c2Vtb3ZlJywgdGhpcy5fbW92ZSk7XHJcbiAgICAgICAgd2luZG93LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ21vdXNldXAnLCB0aGlzLl9wb2ludGVyRW5kKTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogQ2FsbCB0aGUgc3RhcnQgY2FsbGJhY2sgZm9yIHRoaXMgcG9pbnRlciwgYW5kIHRyYWNrIGl0IGlmIHRoZSB1c2VyIHdhbnRzLlxyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSBwb2ludGVyIFBvaW50ZXJcclxuICAgICAqIEBwYXJhbSBldmVudCBSZWxhdGVkIGV2ZW50XHJcbiAgICAgKiBAcmV0dXJucyBXaGV0aGVyIHRoZSBwb2ludGVyIGlzIGJlaW5nIHRyYWNrZWQuXHJcbiAgICAgKi9cclxuICAgIF90cmlnZ2VyUG9pbnRlclN0YXJ0KHBvaW50ZXIsIGV2ZW50KSB7XHJcbiAgICAgICAgaWYgKCF0aGlzLl9zdGFydENhbGxiYWNrKHBvaW50ZXIsIGV2ZW50KSlcclxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgICAgIHRoaXMuY3VycmVudFBvaW50ZXJzLnB1c2gocG9pbnRlcik7XHJcbiAgICAgICAgdGhpcy5zdGFydFBvaW50ZXJzLnB1c2gocG9pbnRlcik7XHJcbiAgICAgICAgcmV0dXJuIHRydWU7XHJcbiAgICB9XHJcbn1cblxuZXhwb3J0IGRlZmF1bHQgUG9pbnRlclRyYWNrZXI7XG4iXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/pointer-tracker/dist/PointerTracker.mjs\n");

/***/ }),

/***/ "./src/importTest.ts":
/*!***************************!*\
  !*** ./src/importTest.ts ***!
  \***************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"add\": () => (/* binding */ add)\n/* harmony export */ });\nfunction add(a, b) {\n    return a + b;\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9kbmQtdHlwZXNjcmlwdC8uL3NyYy9pbXBvcnRUZXN0LnRzP2UyMmUiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6Ijs7OztBQUFPLFNBQVMsR0FBRyxDQUFDLENBQVMsRUFBRSxDQUFTO0lBQ3BDLE9BQU8sQ0FBQyxHQUFHLENBQUMsQ0FBQztBQUNqQixDQUFDIiwiZmlsZSI6Ii4vc3JjL2ltcG9ydFRlc3QudHMuanMiLCJzb3VyY2VzQ29udGVudCI6WyJleHBvcnQgZnVuY3Rpb24gYWRkKGE6IG51bWJlciwgYjogbnVtYmVyKTogbnVtYmVyIHtcbiAgICByZXR1cm4gYSArIGI7XG59Il0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./src/importTest.ts\n");

/***/ }),

/***/ "./src/index.ts":
/*!**********************!*\
  !*** ./src/index.ts ***!
  \**********************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var pointer_tracker__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! pointer-tracker */ \"./node_modules/pointer-tracker/dist/PointerTracker.mjs\");\n/* harmony import */ var _importTest__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./importTest */ \"./src/importTest.ts\");\n\n\nconsole.log('Hello world!');\nconsole.log('Hello again!');\nconsole.log((0,_importTest__WEBPACK_IMPORTED_MODULE_1__.add)(9, 28));\nlet dragObject = document.getElementById('drag-object');\nconst pointerTracker = new pointer_tracker__WEBPACK_IMPORTED_MODULE_0__.default(dragObject, {\n    start(pointer, event) {\n        // Called when a pointer is pressed/touched within the element.\n        // pointer - The new pointer. This pointer isn't included in this.currentPointers or\n        //    this.startPointers yet.\n        // event - The event related to this pointer.\n        // console.log(event)\n        // console.log(pointer)\n        return true;\n    },\n    move(previousPointers, changedPointers, event) {\n        // Called when pointers have moved.\n        // previousPointers - The state of the pointers before this event. This contains the same number\n        //   of pointers, in the same order, as this.currentPointers and this.startPointers.\n        // changedPointers - The pointers that have changed since the last move callback.\n        // event - The event related to the pointer changes.\n        console.log(event);\n    },\n    end(pointer, event, cancelled) {\n        // Called when a pointer is released.\n        // pointer - The final state of the pointer that ended. This pointer is now absent from\n        //   this.currentPointers and this.startPointers.\n        // event - The event related to this pointer.\n        // cancelled - True if the event was cancelled.  Actions are cancelled when the OS takes over\n        //   pointer events, for actions such as scrolling.\n        console.log(event);\n    },\n    // Use raw pointer updates? Pointer events are usually synchronised to requestAnimationFrame.\n    // However, if you're targeting a desynchronised canvas, then faster 'raw' updates are better.\n    // The default is false.\n    // rawUpdates: false,\n});\nvar mouseOffsetX = 0;\nvar mouseOffsetY = 0;\nfunction handleDragStart(e) {\n    mouseOffsetX = e.offsetX;\n    mouseOffsetY = e.offsetY;\n}\nfunction handleDrag(e) {\n    const mousePositionY = e.clientY;\n    const mousePositionX = e.clientX;\n    dragObject === null || dragObject === void 0 ? void 0 : dragObject.style.setProperty('top', `${mousePositionY - mouseOffsetY}px`);\n    dragObject === null || dragObject === void 0 ? void 0 : dragObject.style.setProperty('left', `${mousePositionX - mouseOffsetX}px`);\n}\nfunction handleDragEnd(e) {\n    // out of bounds on left side\n    if (e.clientX - mouseOffsetX < 20) {\n        console.log('out of bounds');\n        dragObject === null || dragObject === void 0 ? void 0 : dragObject.style.setProperty('left', `20px`);\n    }\n    // out of bounds on top side\n    if (e.clientY - mouseOffsetY < 20) {\n        console.log('out of bounds');\n        dragObject === null || dragObject === void 0 ? void 0 : dragObject.style.setProperty('top', `20px`);\n    }\n    if (dragObject) {\n        // out of bounds on right side\n        if ((e.clientX + (dragObject.offsetWidth - mouseOffsetX)) > (window.innerWidth - 20)) {\n            console.log('out of bounds');\n            dragObject.style.setProperty('left', `${window.innerWidth - dragObject.offsetWidth - 20}px`);\n        }\n        // out of bounds on bottom side\n        if ((e.clientY + (dragObject.offsetHeight - mouseOffsetY)) > (window.innerHeight - 20)) {\n            console.log('out of bounds');\n            dragObject.style.setProperty('top', `${window.innerHeight - dragObject.offsetHeight - 20}px`);\n        }\n    }\n}\n// keep element within bounds on window resize\nwindow.addEventListener('resize', () => {\n    // get distance to each edge of div from top and left of window\n    var rect = dragObject === null || dragObject === void 0 ? void 0 : dragObject.getBoundingClientRect();\n    if (rect) {\n        if (rect.right > window.innerWidth) {\n            dragObject === null || dragObject === void 0 ? void 0 : dragObject.style.setProperty('left', `${window.innerWidth - dragObject.offsetWidth - 20}px`);\n        }\n        if (rect.bottom > window.innerHeight) {\n            dragObject === null || dragObject === void 0 ? void 0 : dragObject.style.setProperty('top', `${window.innerHeight - dragObject.offsetHeight - 20}px`);\n        }\n    }\n});\ndocument.addEventListener(\"dragover\", function (event) {\n    // prevent default to allow drop\n    event.preventDefault();\n}, false);\nfunction handleCentre() {\n    dragObject === null || dragObject === void 0 ? void 0 : dragObject.style.setProperty('top', `${window.innerHeight / 2 - dragObject.offsetHeight / 2}px`);\n    dragObject === null || dragObject === void 0 ? void 0 : dragObject.style.setProperty('left', `${window.innerWidth / 2 - dragObject.offsetWidth / 2}px`);\n}\n// function distanceMagnitude(a: Point, b?: Point): number {\n//     if (!b) return 0 \n//     else return Math.sqrt((b.clientX - a.clientX) ** 2 + (b.clientY - a.clientY) ** 2);\n// }\n// if magnitude increases make div bigger by same percentage distance changes\n// min_scale = 0.4 max_scale = 4\n// if drop point + width/2 > window.innerWidth - 20 or height/2 > window.innerHeight - 20 dont allow\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9kbmQtdHlwZXNjcmlwdC8uL3NyYy9pbmRleC50cz9mZmI0Il0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7OztBQUE2QztBQUNWO0FBRW5DLE9BQU8sQ0FBQyxHQUFHLENBQUMsY0FBYyxDQUFDO0FBQzNCLE9BQU8sQ0FBQyxHQUFHLENBQUMsY0FBYyxDQUFDO0FBRTNCLE9BQU8sQ0FBQyxHQUFHLENBQUMsZ0RBQUcsQ0FBQyxDQUFDLEVBQUUsRUFBRSxDQUFDLENBQUM7QUFFdkIsSUFBSSxVQUFVLEdBQUcsUUFBUSxDQUFDLGNBQWMsQ0FBQyxhQUFhLENBQUU7QUFFeEQsTUFBTSxjQUFjLEdBQUcsSUFBSSxvREFBYyxDQUFDLFVBQVUsRUFBRTtJQUNsRCxLQUFLLENBQUMsT0FBWSxFQUFFLEtBQVU7UUFDMUIsK0RBQStEO1FBQy9ELG9GQUFvRjtRQUNwRiw2QkFBNkI7UUFDN0IsNkNBQTZDO1FBQzdDLHFCQUFxQjtRQUNyQix1QkFBdUI7UUFDdkIsT0FBTyxJQUFJLENBQUM7SUFDaEIsQ0FBQztJQUNELElBQUksQ0FBQyxnQkFBZ0IsRUFBRSxlQUFlLEVBQUUsS0FBSztRQUN6QyxtQ0FBbUM7UUFDbkMsZ0dBQWdHO1FBQ2hHLG9GQUFvRjtRQUNwRixpRkFBaUY7UUFDakYsb0RBQW9EO1FBQ3BELE9BQU8sQ0FBQyxHQUFHLENBQUMsS0FBSyxDQUFDO0lBQ3RCLENBQUM7SUFDRCxHQUFHLENBQUMsT0FBTyxFQUFFLEtBQUssRUFBRSxTQUFTO1FBQ3pCLHFDQUFxQztRQUNyQyx1RkFBdUY7UUFDdkYsaURBQWlEO1FBQ2pELDZDQUE2QztRQUM3Qyw2RkFBNkY7UUFDN0YsbURBQW1EO1FBQ25ELE9BQU8sQ0FBQyxHQUFHLENBQUMsS0FBSyxDQUFDO0lBQ3RCLENBQUM7SUFDRCw2RkFBNkY7SUFDN0YsOEZBQThGO0lBQzlGLHdCQUF3QjtJQUN4QixxQkFBcUI7Q0FDeEIsQ0FBQyxDQUFDO0FBRUgsSUFBSSxZQUFZLEdBQUcsQ0FBQyxDQUFDO0FB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SSxDQUFDLENBQUM7U0FDakc7UUFDRCxJQUFJLElBQUksQ0FBQyxNQUFNLEdBQUcsTUFBTSxDQUFDLFdBQVcsRUFBRTtZQUNsQyxVQUFVLGFBQVYsVUFBVSx1QkFBVixVQUFVLENBQUUsS0FBSyxDQUFDLFdBQVcsQ0FBQyxLQUFLLEVBQUUsR0FBRyxNQUFNLENBQUMsV0FBVyxHQUFHLFVBQVUsQ0FBQyxZQUFZLEdBQUcsRUFBRSxJQUFJLENBQUMsQ0FBQztTQUNsRztLQUNKO0FBRUwsQ0FBQyxDQUFDLENBQUM7QUFFSCxRQUFRLENBQUMsZ0JBQWdCLENBQUMsVUFBVSxFQUFFLFVBQVUsS0FBSztJQUNqRCxnQ0FBZ0M7SUFDaEMsS0FBSyxDQUFDLGNBQWMsRUFBRSxDQUFDO0FBQzNCLENBQUMsRUFBRSxLQUFLLENBQUMsQ0FBQztBQUVWLFNBQVMsWUFBWTtJQUNqQixVQUFVLGFBQVYsVUFBVSx1QkFBVixVQUFVLENBQUUsS0FBSyxDQUFDLFdBQVcsQ0FBQyxLQUFLLEVBQUUsR0FBRyxNQUFNLENBQUMsV0FBVyxHQUFHLENBQUMsR0FBRyxVQUFVLENBQUMsWUFBWSxHQUFHLENBQUMsSUFBSSxDQUFDLENBQUM7SUFDbEcsVUFBVSxhQUFWLFVBQVUsdUJBQVYsVUFBVSxDQUFFLEtBQUssQ0FBQyxXQUFXLENBQUMsTUFBTSxFQUFFLEdBQUcsTUFBTSxDQUFDLFVBQVUsR0FBRyxDQUFDLEdBQUcsVUFBVSxDQUFDLFdBQVcsR0FBRyxDQUFDLElBQUksQ0FBQyxDQUFDO0FBQ3JHLENBQUM7QUFFRCw0REFBNEQ7QUFDNUQsd0JBQXdCO0FBQ3hCLDBGQUEwRjtBQUMxRixJQUFJO0FBRUosNkVBQTZFO0FBRTdFLGdDQUFnQztBQUVoQyxvR0FBb0ciLCJmaWxlIjoiLi9zcmMvaW5kZXgudHMuanMiLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgUG9pbnRlclRyYWNrZXIgZnJvbSAncG9pbnRlci10cmFja2VyJztcbmltcG9ydCB7IGFkZCB9IGZyb20gJy4vaW1wb3J0VGVzdCc7XG5cbmNvbnNvbGUubG9nKCdIZWxsbyB3b3JsZCEnKVxuY29uc29sZS5sb2coJ0hlbGxvIGFnYWluIScpXG5cbmNvbnNvbGUubG9nKGFkZCg5LCAyOCkpXG5cbmxldCBkcmFnT2JqZWN0ID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoJ2RyYWctb2JqZWN0JykhXG5cbmNvbnN0IHBvaW50ZXJUcmFja2VyID0gbmV3IFBvaW50ZXJUcmFja2VyKGRyYWdPYmplY3QsIHtcbiAgICBzdGFydChwb2ludGVyOiBhbnksIGV2ZW50OiBhbnkpIHtcbiAgICAgICAgLy8gQ2FsbGVkIHdoZW4gYSBwb2ludGVyIGlzIHByZXNzZWQvdG91Y2hlZCB3aXRoaW4gdGhlIGVsZW1lbnQuXG4gICAgICAgIC8vIHBvaW50ZXIgLSBUaGUgbmV3IHBvaW50ZXIuIFRoaXMgcG9pbnRlciBpc24ndCBpbmNsdWRlZCBpbiB0aGlzLmN1cnJlbnRQb2ludGVycyBvclxuICAgICAgICAvLyAgICB0aGlzLnN0YXJ0UG9pbnRlcnMgeWV0LlxuICAgICAgICAvLyBldmVudCAtIFRoZSBldmVudCByZWxhdGVkIHRvIHRoaXMgcG9pbnRlci5cbiAgICAgICAgLy8gY29uc29sZS5sb2coZXZlbnQpXG4gICAgICAgIC8vIGNvbnNvbGUubG9nKHBvaW50ZXIpXG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH0sXG4gICAgbW92ZShwcmV2aW91c1BvaW50ZXJzLCBjaGFuZ2VkUG9pbnRlcnMsIGV2ZW50KSB7XG4gICAgICAgIC8vIENhbGxlZCB3aGVuIHBvaW50ZXJzIGhhdmUgbW92ZWQuXG4gICAgICAgIC8vIHByZXZpb3VzUG9pbnRlcnMgLSBUaGUgc3RhdGUgb2YgdGhlIHBvaW50ZXJzIGJlZm9yZSB0aGlzIGV2ZW50LiBUaGlzIGNvbnRhaW5zIHRoZSBzYW1lIG51bWJlclxuICAgICAgICAvLyAgIG9mIHBvaW50ZXJzLCBpbiB0aGUgc2FtZSBvcmRlciwgYXMgdGhpcy5jdXJyZW50UG9pbnRlcnMgYW5kIHRoaXMuc3RhcnRQb2ludGVycy5cbiAgICAgICAgLy8gY2hhbmdlZFBvaW50ZXJzIC0gVGhlIHBvaW50ZXJzIHRoYXQgaGF2ZSBjaGFuZ2VkIHNpbmNlIHRoZSBsYXN0IG1vdmUgY2FsbGJhY2suXG4gICAgICAgIC8vIGV2ZW50IC0gVGhlIGV2ZW50IHJlbGF0ZWQgdG8gdGhlIHBvaW50ZXIgY2hhbmdlcy5cbiAgICAgICAgY29uc29sZS5sb2coZXZlbnQpXG4gICAgfSxcbiAgICBlbmQocG9pbnRlciwgZXZlbnQsIGNhbmNlbGxlZCkge1xuICAgICAgICAvLyBDYWxsZWQgd2hlbiBhIHBvaW50ZXIgaXMgcmVsZWFzZWQuXG4gICAgICAgIC8vIHBvaW50ZXIgLSBUaGUgZmluYWwgc3RhdGUgb2YgdGhlIHBvaW50ZXIgdGhhdCBlbmRlZC4gVGhpcyBwb2ludGVyIGlzIG5vdyBhYnNlbnQgZnJvbVxuICAgICAgICAvLyAgIHRoaXMuY3VycmVudFBvaW50ZXJzIGFuZCB0aGlzLnN0YXJ0UG9pbnRlcnMuXG4gICAgICAgIC8vIGV2ZW50IC0gVGhlIGV2ZW50IHJlbGF0ZWQgdG8gdGhpcyBwb2ludGVyLlxuICAgICAgICAvLyBjYW5jZWxsZWQgLSBUcnVlIGlmIHRoZSBldmVudCB3YXMgY2FuY2VsbGVkLiAgQWN0aW9ucyBhcmUgY2FuY2VsbGVkIHdoZW4gdGhlIE9TIHRha2VzIG92ZXJcbiAgICAgICAgLy8gICBwb2ludGVyIGV2ZW50cywgZm9yIGFjdGlvbnMgc3VjaCBhcyBzY3JvbGxpbmcuXG4gICAgICAgIGNvbnNvbGUubG9nKGV2ZW50KVxuICAgIH0sXG4gICAgLy8gVXNlIHJhdyBwb2ludGVyIHVwZGF0ZXM/IFBvaW50ZXIgZXZlbnRzIGFyZSB1c3VhbGx5IHN5bmNocm9uaXNlZCB0byByZXF1ZXN0QW5pbWF0aW9uRnJhbWUuXG4gICAgLy8gSG93ZXZlciwgaWYgeW91J3JlIHRhcmdldGluZyBhIGRlc3luY2hyb25pc2VkIGNhbnZhcywgdGhlbiBmYXN0ZXIgJ3JhdycgdXBkYXRlcyBhcmUgYmV0dGVyLlxuICAgIC8vIFRoZSBkZWZhdWx0IGlzIGZhbHNlLlxuICAgIC8vIHJhd1VwZGF0ZXM6IGZhbHNlLFxufSk7XG5cbnZhciBtb3VzZU9mZnNldFggPSAwO1xudmFyIG1vdXNlT2Zmc2V0WSA9IDA7XG5cbmZ1bmN0aW9uIGhhbmRsZURyYWdTdGFydChlOiBhbnkpIHtcbiAgICBtb3VzZU9mZnNldFggPSBlLm9mZnNldFg7XG4gICAgbW91c2VPZmZzZXRZID0gZS5vZmZzZXRZO1xufVxuXG5mdW5jdGlvbiBoYW5kbGVEcmFnKGU6IGFueSkge1xuICAgIGNvbnN0IG1vdXNlUG9zaXRpb25ZID0gZS5jbGllbnRZO1xuICAgIGNvbnN0IG1vdXNlUG9zaXRpb25YID0gZS5jbGllbnRYO1xuICAgIGRyYWdPYmplY3Q/LnN0eWxlLnNldFByb3BlcnR5KCd0b3AnLCBgJHttb3VzZVBvc2l0aW9uWSAtIG1vdXNlT2Zmc2V0WX1weGApO1xuICAgIGRyYWdPYmplY3Q/LnN0eWxlLnNldFByb3BlcnR5KCdsZWZ0JywgYCR7bW91c2VQb3NpdGlvblggLSBtb3VzZU9mZnNldFh9cHhgKTtcbn1cblxuZnVuY3Rpb24gaGFuZGxlRHJhZ0VuZChlOiBhbnkpIHtcbiAgICAvLyBvdXQgb2YgYm91bmRzIG9uIGxlZnQgc2lkZVxuICAgIGlmIChlLmNsaWVudFggLSBtb3VzZU9mZnNldFggPCAyMCkge1xuICAgICAgICBjb25zb2xlLmxvZygnb3V0IG9mIGJvdW5kcycpXG4gICAgICAgIGRyYWdPYmplY3Q/LnN0eWxlLnNldFByb3BlcnR5KCdsZWZ0JywgYDIwcHhgKTtcbiAgICB9XG4gICAgLy8gb3V0IG9mIGJvdW5kcyBvbiB0b3Agc2lkZVxuICAgIGlmIChlLmNsaWVudFkgLSBtb3VzZU9mZnNldFkgPCAyMCkge1xuICAgICAgICBjb25zb2xlLmxvZygnb3V0IG9mIGJvdW5kcycpXG4gICAgICAgIGRyYWdPYmplY3Q/LnN0eWxlLnNldFByb3BlcnR5KCd0b3AnLCBgMjBweGApO1xuICAgIH1cbiAgICBpZiAoZHJhZ09iamVjdCkge1xuICAgICAgICAvLyBvdXQgb2YgYm91bmRzIG9uIHJpZ2h0IHNpZGVcbiAgICAgICAgaWYgKChlLmNsaWVudFggKyAoZHJhZ09iamVjdC5vZmZzZXRXaWR0aCAtIG1vdXNlT2Zmc2V0WCkpID4gKHdpbmRvdy5pbm5lcldpZHRoIC0gMjApKSB7XG4gICAgICAgICAgICBjb25zb2xlLmxvZygnb3V0IG9mIGJvdW5kcycpXG4gICAgICAgICAgICBkcmFnT2JqZWN0LnN0eWxlLnNldFByb3BlcnR5KCdsZWZ0JywgYCR7d2luZG93LmlubmVyV2lkdGggLSBkcmFnT2JqZWN0Lm9mZnNldFdpZHRoIC0gMjB9cHhgKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBvdXQgb2YgYm91bmRzIG9uIGJvdHRvbSBzaWRlXG4gICAgICAgIGlmICgoZS5jbGllbnRZICsgKGRyYWdPYmplY3Qub2Zmc2V0SGVpZ2h0IC0gbW91c2VPZmZzZXRZKSkgPiAod2luZG93LmlubmVySGVpZ2h0IC0gMjApKSB7XG4gICAgICAgICAgICBjb25zb2xlLmxvZygnb3V0IG9mIGJvdW5kcycpXG4gICAgICAgICAgICBkcmFnT2JqZWN0LnN0eWxlLnNldFByb3BlcnR5KCd0b3AnLCBgJHt3aW5kb3cuaW5uZXJIZWlnaHQgLSBkcmFnT2JqZWN0Lm9mZnNldEhlaWdodCAtIDIwfXB4YCk7XG4gICAgICAgIH1cbiAgICB9XG59XG5cbi8vIGtlZXAgZWxlbWVudCB3aXRoaW4gYm91bmRzIG9uIHdpbmRvdyByZXNpemVcbndpbmRvdy5hZGRFdmVudExpc3RlbmVyKCdyZXNpemUnLCAoKSA9PiB7XG4gICAgLy8gZ2V0IGRpc3RhbmNlIHRvIGVhY2ggZWRnZSBvZiBkaXYgZnJvbSB0b3AgYW5kIGxlZnQgb2Ygd2luZG93XG4gICAgdmFyIHJlY3QgPSBkcmFnT2JqZWN0Py5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcbiAgICBpZiAocmVjdCkge1xuICAgICAgICBpZiAocmVjdC5yaWdodCA+IHdpbmRvdy5pbm5lcldpZHRoKSB7XG4gICAgICAgICAgICBkcmFnT2JqZWN0Py5zdHlsZS5zZXRQcm9wZXJ0eSgnbGVmdCcsIGAke3dpbmRvdy5pbm5lcldpZHRoIC0gZHJhZ09iamVjdC5vZmZzZXRXaWR0aCAtIDIwfXB4YCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHJlY3QuYm90dG9tID4gd2luZG93LmlubmVySGVpZ2h0KSB7XG4gICAgICAgICAgICBkcmFnT2JqZWN0Py5zdHlsZS5zZXRQcm9wZXJ0eSgndG9wJywgYCR7d2luZG93LmlubmVySGVpZ2h0IC0gZHJhZ09iamVjdC5vZmZzZXRIZWlnaHQgLSAyMH1weGApO1xuICAgICAgICB9XG4gICAgfVxuXG59KTtcblxuZG9jdW1lbnQuYWRkRXZlbnRMaXN0ZW5lcihcImRyYWdvdmVyXCIsIGZ1bmN0aW9uIChldmVudCkge1xuICAgIC8vIHByZXZlbnQgZGVmYXVsdCB0byBhbGxvdyBkcm9wXG4gICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcbn0sIGZhbHNlKTtcblxuZnVuY3Rpb24gaGFuZGxlQ2VudHJlKCkge1xuICAgIGRyYWdPYmplY3Q/LnN0eWxlLnNldFByb3BlcnR5KCd0b3AnLCBgJHt3aW5kb3cuaW5uZXJIZWlnaHQgLyAyIC0gZHJhZ09iamVjdC5vZmZzZXRIZWlnaHQgLyAyfXB4YCk7XG4gICAgZHJhZ09iamVjdD8uc3R5bGUuc2V0UHJvcGVydHkoJ2xlZnQnLCBgJHt3aW5kb3cuaW5uZXJXaWR0aCAvIDIgLSBkcmFnT2JqZWN0Lm9mZnNldFdpZHRoIC8gMn1weGApO1xufVxuXG4vLyBmdW5jdGlvbiBkaXN0YW5jZU1hZ25pdHVkZShhOiBQb2ludCwgYj86IFBvaW50KTogbnVtYmVyIHtcbi8vICAgICBpZiAoIWIpIHJldHVybiAwIFxuLy8gICAgIGVsc2UgcmV0dXJuIE1hdGguc3FydCgoYi5jbGllbnRYIC0gYS5jbGllbnRYKSAqKiAyICsgKGIuY2xpZW50WSAtIGEuY2xpZW50WSkgKiogMik7XG4vLyB9XG5cbi8vIGlmIG1hZ25pdHVkZSBpbmNyZWFzZXMgbWFrZSBkaXYgYmlnZ2VyIGJ5IHNhbWUgcGVyY2VudGFnZSBkaXN0YW5jZSBjaGFuZ2VzXG5cbi8vIG1pbl9zY2FsZSA9IDAuNCBtYXhfc2NhbGUgPSA0XG5cbi8vIGlmIGRyb3AgcG9pbnQgKyB3aWR0aC8yID4gd2luZG93LmlubmVyV2lkdGggLSAyMCBvciBoZWlnaHQvMiA+IHdpbmRvdy5pbm5lckhlaWdodCAtIDIwIGRvbnQgYWxsb3dcbiJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./src/index.ts\n");

/***/ })

/******/ 	});
/************************************************************************/
/******/ 	// The module cache
/******/ 	var __webpack_module_cache__ = {};
/******/ 	
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/ 		// Check if module is in cache
/******/ 		var cachedModule = __webpack_module_cache__[moduleId];
/******/ 		if (cachedModule !== undefined) {
/******/ 			return cachedModule.exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = __webpack_module_cache__[moduleId] = {
/******/ 			// no module.id needed
/******/ 			// no module.loaded needed
/******/ 			exports: {}
/******/ 		};
/******/ 	
/******/ 		// Execute the module function
/******/ 		__webpack_modules__[moduleId](module, module.exports, __webpack_require__);
/******/ 	
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/ 	
/************************************************************************/
/******/ 	/* webpack/runtime/define property getters */
/******/ 	(() => {
/******/ 		// define getter functions for harmony exports
/******/ 		__webpack_require__.d = (exports, definition) => {
/******/ 			for(var key in definition) {
/******/ 				if(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {
/******/ 					Object.defineProperty(exports, key, { enumerable: true, get: definition[key] });
/******/ 				}
/******/ 			}
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/hasOwnProperty shorthand */
/******/ 	(() => {
/******/ 		__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/make namespace object */
/******/ 	(() => {
/******/ 		// define __esModule on exports
/******/ 		__webpack_require__.r = (exports) => {
/******/ 			if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 				Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 			}
/******/ 			Object.defineProperty(exports, '__esModule', { value: true });
/******/ 		};
/******/ 	})();
/******/ 	
/************************************************************************/
/******/ 	
/******/ 	// startup
/******/ 	// Load entry module and return exports
/******/ 	// This entry module can't be inlined because the eval-source-map devtool is used.
/******/ 	var __webpack_exports__ = __webpack_require__("./src/index.ts");
/******/ 	
/******/ })()
;