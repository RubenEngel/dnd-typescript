/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
/******/ (() => { // webpackBootstrap
/******/ 	"use strict";
/******/ 	var __webpack_modules__ = ({

/***/ "./node_modules/pointer-tracker/dist/PointerTracker.mjs":
/*!**************************************************************!*\
  !*** ./node_modules/pointer-tracker/dist/PointerTracker.mjs ***!
  \**************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\nclass Pointer {\r\n    constructor(nativePointer) {\r\n        /** Unique ID for this pointer */\r\n        this.id = -1;\r\n        this.nativePointer = nativePointer;\r\n        this.pageX = nativePointer.pageX;\r\n        this.pageY = nativePointer.pageY;\r\n        this.clientX = nativePointer.clientX;\r\n        this.clientY = nativePointer.clientY;\r\n        if (self.Touch && nativePointer instanceof Touch) {\r\n            this.id = nativePointer.identifier;\r\n        }\r\n        else if (isPointerEvent(nativePointer)) {\r\n            // is PointerEvent\r\n            this.id = nativePointer.pointerId;\r\n        }\r\n    }\r\n    /**\r\n     * Returns an expanded set of Pointers for high-resolution inputs.\r\n     */\r\n    getCoalesced() {\r\n        if ('getCoalescedEvents' in this.nativePointer) {\r\n            return this.nativePointer.getCoalescedEvents().map((p) => new Pointer(p));\r\n        }\r\n        return [this];\r\n    }\r\n}\r\nconst isPointerEvent = (event) => self.PointerEvent && event instanceof PointerEvent;\r\nconst noop = () => { };\r\n/**\r\n * Track pointers across a particular element\r\n */\r\nclass PointerTracker {\r\n    /**\r\n     * Track pointers across a particular element\r\n     *\r\n     * @param element Element to monitor.\r\n     * @param options\r\n     */\r\n    constructor(_element, { start = () => true, move = noop, end = noop, rawUpdates = false, } = {}) {\r\n        this._element = _element;\r\n        /**\r\n         * State of the tracked pointers when they were pressed/touched.\r\n         */\r\n        this.startPointers = [];\r\n        /**\r\n         * Latest state of the tracked pointers. Contains the same number of pointers, and in the same\r\n         * order as this.startPointers.\r\n         */\r\n        this.currentPointers = [];\r\n        /**\r\n         * Listener for mouse/pointer starts.\r\n         *\r\n         * @param event This will only be a MouseEvent if the browser doesn't support pointer events.\r\n         */\r\n        this._pointerStart = (event) => {\r\n            if (event.button !== 0 /* Left */)\r\n                return;\r\n            if (!this._triggerPointerStart(new Pointer(event), event))\r\n                return;\r\n            // Add listeners for additional events.\r\n            // The listeners may already exist, but no harm in adding them again.\r\n            if (isPointerEvent(event)) {\r\n                const capturingElement = event.target && 'setPointerCapture' in event.target\r\n                    ? event.target\r\n                    : this._element;\r\n                capturingElement.setPointerCapture(event.pointerId);\r\n                this._element.addEventListener(this._rawUpdates ? 'pointerrawupdate' : 'pointermove', this._move);\r\n                this._element.addEventListener('pointerup', this._pointerEnd);\r\n                this._element.addEventListener('pointercancel', this._pointerEnd);\r\n            }\r\n            else {\r\n                // MouseEvent\r\n                window.addEventListener('mousemove', this._move);\r\n                window.addEventListener('mouseup', this._pointerEnd);\r\n            }\r\n        };\r\n        /**\r\n         * Listener for touchstart.\r\n         * Only used if the browser doesn't support pointer events.\r\n         */\r\n        this._touchStart = (event) => {\r\n            for (const touch of Array.from(event.changedTouches)) {\r\n                this._triggerPointerStart(new Pointer(touch), event);\r\n            }\r\n        };\r\n        /**\r\n         * Listener for pointer/mouse/touch move events.\r\n         */\r\n        this._move = (event) => {\r\n            const previousPointers = this.currentPointers.slice();\r\n            const changedPointers = 'changedTouches' in event // Shortcut for 'is touch event'.\r\n                ? Array.from(event.changedTouches).map((t) => new Pointer(t))\r\n                : [new Pointer(event)];\r\n            const trackedChangedPointers = [];\r\n            for (const pointer of changedPointers) {\r\n                const index = this.currentPointers.findIndex((p) => p.id === pointer.id);\r\n                if (index === -1)\r\n                    continue; // Not a pointer we're tracking\r\n                trackedChangedPointers.push(pointer);\r\n                this.currentPointers[index] = pointer;\r\n            }\r\n            if (trackedChangedPointers.length === 0)\r\n                return;\r\n            this._moveCallback(previousPointers, trackedChangedPointers, event);\r\n        };\r\n        /**\r\n         * Call the end callback for this pointer.\r\n         *\r\n         * @param pointer Pointer\r\n         * @param event Related event\r\n         */\r\n        this._triggerPointerEnd = (pointer, event) => {\r\n            const index = this.currentPointers.findIndex((p) => p.id === pointer.id);\r\n            // Not a pointer we're interested in?\r\n            if (index === -1)\r\n                return false;\r\n            this.currentPointers.splice(index, 1);\r\n            this.startPointers.splice(index, 1);\r\n            const cancelled = event.type === 'touchcancel' || event.type === 'pointercancel';\r\n            this._endCallback(pointer, event, cancelled);\r\n            return true;\r\n        };\r\n        /**\r\n         * Listener for mouse/pointer ends.\r\n         *\r\n         * @param event This will only be a MouseEvent if the browser doesn't support pointer events.\r\n         */\r\n        this._pointerEnd = (event) => {\r\n            if (!this._triggerPointerEnd(new Pointer(event), event))\r\n                return;\r\n            if (isPointerEvent(event)) {\r\n                if (this.currentPointers.length)\r\n                    return;\r\n                this._element.removeEventListener(this._rawUpdates ? 'pointerrawupdate' : 'pointermove', this._move);\r\n                this._element.removeEventListener('pointerup', this._pointerEnd);\r\n                this._element.removeEventListener('pointercancel', this._pointerEnd);\r\n            }\r\n            else {\r\n                // MouseEvent\r\n                window.removeEventListener('mousemove', this._move);\r\n                window.removeEventListener('mouseup', this._pointerEnd);\r\n            }\r\n        };\r\n        /**\r\n         * Listener for touchend.\r\n         * Only used if the browser doesn't support pointer events.\r\n         */\r\n        this._touchEnd = (event) => {\r\n            for (const touch of Array.from(event.changedTouches)) {\r\n                this._triggerPointerEnd(new Pointer(touch), event);\r\n            }\r\n        };\r\n        this._startCallback = start;\r\n        this._moveCallback = move;\r\n        this._endCallback = end;\r\n        this._rawUpdates = rawUpdates && 'onpointerrawupdate' in window;\r\n        // Add listeners\r\n        if (self.PointerEvent) {\r\n            this._element.addEventListener('pointerdown', this._pointerStart);\r\n        }\r\n        else {\r\n            this._element.addEventListener('mousedown', this._pointerStart);\r\n            this._element.addEventListener('touchstart', this._touchStart);\r\n            this._element.addEventListener('touchmove', this._move);\r\n            this._element.addEventListener('touchend', this._touchEnd);\r\n            this._element.addEventListener('touchcancel', this._touchEnd);\r\n        }\r\n    }\r\n    /**\r\n     * Remove all listeners.\r\n     */\r\n    stop() {\r\n        this._element.removeEventListener('pointerdown', this._pointerStart);\r\n        this._element.removeEventListener('mousedown', this._pointerStart);\r\n        this._element.removeEventListener('touchstart', this._touchStart);\r\n        this._element.removeEventListener('touchmove', this._move);\r\n        this._element.removeEventListener('touchend', this._touchEnd);\r\n        this._element.removeEventListener('touchcancel', this._touchEnd);\r\n        this._element.removeEventListener(this._rawUpdates ? 'pointerrawupdate' : 'pointermove', this._move);\r\n        this._element.removeEventListener('pointerup', this._pointerEnd);\r\n        this._element.removeEventListener('pointercancel', this._pointerEnd);\r\n        window.removeEventListener('mousemove', this._move);\r\n        window.removeEventListener('mouseup', this._pointerEnd);\r\n    }\r\n    /**\r\n     * Call the start callback for this pointer, and track it if the user wants.\r\n     *\r\n     * @param pointer Pointer\r\n     * @param event Related event\r\n     * @returns Whether the pointer is being tracked.\r\n     */\r\n    _triggerPointerStart(pointer, event) {\r\n        if (!this._startCallback(pointer, event))\r\n            return false;\r\n        this.currentPointers.push(pointer);\r\n        this.startPointers.push(pointer);\r\n        return true;\r\n    }\r\n}\n\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (PointerTracker);\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9kbmQtdHlwZXNjcmlwdC8uL25vZGVfbW9kdWxlcy9wb2ludGVyLXRyYWNrZXIvZGlzdC9Qb2ludGVyVHJhY2tlci5tanM/YWI1NiJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiOzs7O0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0I7QUFDcEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQkFBMkIsbUVBQW1FLEtBQUs7QUFDbkc7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2QkFBNkI7QUFDN0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxpRUFBZSxjQUFjLEVBQUMiLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvcG9pbnRlci10cmFja2VyL2Rpc3QvUG9pbnRlclRyYWNrZXIubWpzLmpzIiwic291cmNlc0NvbnRlbnQiOlsiY2xhc3MgUG9pbnRlciB7XHJcbiAgICBjb25zdHJ1Y3RvcihuYXRpdmVQb2ludGVyKSB7XHJcbiAgICAgICAgLyoqIFVuaXF1ZSBJRCBmb3IgdGhpcyBwb2ludGVyICovXHJcbiAgICAgICAgdGhpcy5pZCA9IC0xO1xyXG4gICAgICAgIHRoaXMubmF0aXZlUG9pbnRlciA9IG5hdGl2ZVBvaW50ZXI7XHJcbiAgICAgICAgdGhpcy5wYWdlWCA9IG5hdGl2ZVBvaW50ZXIucGFnZVg7XHJcbiAgICAgICAgdGhpcy5wYWdlWSA9IG5hdGl2ZVBvaW50ZXIucGFnZVk7XHJcbiAgICAgICAgdGhpcy5jbGllbnRYID0gbmF0aXZlUG9pbnRlci5jbGllbnRYO1xyXG4gICAgICAgIHRoaXMuY2xpZW50WSA9IG5hdGl2ZVBvaW50ZXIuY2xpZW50WTtcclxuICAgICAgICBpZiAoc2VsZi5Ub3VjaCAmJiBuYXRpdmVQb2ludGVyIGluc3RhbmNlb2YgVG91Y2gpIHtcclxuICAgICAgICAgICAgdGhpcy5pZCA9IG5hdGl2ZVBvaW50ZXIuaWRlbnRpZmllcjtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSBpZiAoaXNQb2ludGVyRXZlbnQobmF0aXZlUG9pbnRlcikpIHtcclxuICAgICAgICAgICAgLy8gaXMgUG9pbnRlckV2ZW50XHJcbiAgICAgICAgICAgIHRoaXMuaWQgPSBuYXRpdmVQb2ludGVyLnBvaW50ZXJJZDtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIFJldHVybnMgYW4gZXhwYW5kZWQgc2V0IG9mIFBvaW50ZXJzIGZvciBoaWdoLXJlc29sdXRpb24gaW5wdXRzLlxyXG4gICAgICovXHJcbiAgICBnZXRDb2FsZXNjZWQoKSB7XHJcbiAgICAgICAgaWYgKCdnZXRDb2FsZXNjZWRFdmVudHMnIGluIHRoaXMubmF0aXZlUG9pbnRlcikge1xyXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5uYXRpdmVQb2ludGVyLmdldENvYWxlc2NlZEV2ZW50cygpLm1hcCgocCkgPT4gbmV3IFBvaW50ZXIocCkpO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gW3RoaXNdO1xyXG4gICAgfVxyXG59XHJcbmNvbnN0IGlzUG9pbnRlckV2ZW50ID0gKGV2ZW50KSA9PiBzZWxmLlBvaW50ZXJFdmVudCAmJiBldmVudCBpbnN0YW5jZW9mIFBvaW50ZXJFdmVudDtcclxuY29uc3Qgbm9vcCA9ICgpID0+IHsgfTtcclxuLyoqXHJcbiAqIFRyYWNrIHBvaW50ZXJzIGFjcm9zcyBhIHBhcnRpY3VsYXIgZWxlbWVudFxyXG4gKi9cclxuY2xhc3MgUG9pbnRlclRyYWNrZXIge1xyXG4gICAgLyoqXHJcbiAgICAgKiBUcmFjayBwb2ludGVycyBhY3Jvc3MgYSBwYXJ0aWN1bGFyIGVsZW1lbnRcclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0gZWxlbWVudCBFbGVtZW50IHRvIG1vbml0b3IuXHJcbiAgICAgKiBAcGFyYW0gb3B0aW9uc1xyXG4gICAgICovXHJcbiAgICBjb25zdHJ1Y3RvcihfZWxlbWVudCwgeyBzdGFydCA9ICgpID0+IHRydWUsIG1vdmUgPSBub29wLCBlbmQgPSBub29wLCByYXdVcGRhdGVzID0gZmFsc2UsIH0gPSB7fSkge1xyXG4gICAgICAgIHRoaXMuX2VsZW1lbnQgPSBfZWxlbWVudDtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBTdGF0ZSBvZiB0aGUgdHJhY2tlZCBwb2ludGVycyB3aGVuIHRoZXkgd2VyZSBwcmVzc2VkL3RvdWNoZWQuXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgdGhpcy5zdGFydFBvaW50ZXJzID0gW107XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogTGF0ZXN0IHN0YXRlIG9mIHRoZSB0cmFja2VkIHBvaW50ZXJzLiBDb250YWlucyB0aGUgc2FtZSBudW1iZXIgb2YgcG9pbnRlcnMsIGFuZCBpbiB0aGUgc2FtZVxyXG4gICAgICAgICAqIG9yZGVyIGFzIHRoaXMuc3RhcnRQb2ludGVycy5cclxuICAgICAgICAgKi9cclxuICAgICAgICB0aGlzLmN1cnJlbnRQb2ludGVycyA9IFtdO1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIExpc3RlbmVyIGZvciBtb3VzZS9wb2ludGVyIHN0YXJ0cy5cclxuICAgICAgICAgKlxyXG4gICAgICAgICAqIEBwYXJhbSBldmVudCBUaGlzIHdpbGwgb25seSBiZSBhIE1vdXNlRXZlbnQgaWYgdGhlIGJyb3dzZXIgZG9lc24ndCBzdXBwb3J0IHBvaW50ZXIgZXZlbnRzLlxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIHRoaXMuX3BvaW50ZXJTdGFydCA9IChldmVudCkgPT4ge1xyXG4gICAgICAgICAgICBpZiAoZXZlbnQuYnV0dG9uICE9PSAwIC8qIExlZnQgKi8pXHJcbiAgICAgICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgICAgIGlmICghdGhpcy5fdHJpZ2dlclBvaW50ZXJTdGFydChuZXcgUG9pbnRlcihldmVudCksIGV2ZW50KSlcclxuICAgICAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICAgICAgLy8gQWRkIGxpc3RlbmVycyBmb3IgYWRkaXRpb25hbCBldmVudHMuXHJcbiAgICAgICAgICAgIC8vIFRoZSBsaXN0ZW5lcnMgbWF5IGFscmVhZHkgZXhpc3QsIGJ1dCBubyBoYXJtIGluIGFkZGluZyB0aGVtIGFnYWluLlxyXG4gICAgICAgICAgICBpZiAoaXNQb2ludGVyRXZlbnQoZXZlbnQpKSB7XHJcbiAgICAgICAgICAgICAgICBjb25zdCBjYXB0dXJpbmdFbGVtZW50ID0gZXZlbnQudGFyZ2V0ICYmICdzZXRQb2ludGVyQ2FwdHVyZScgaW4gZXZlbnQudGFyZ2V0XHJcbiAgICAgICAgICAgICAgICAgICAgPyBldmVudC50YXJnZXRcclxuICAgICAgICAgICAgICAgICAgICA6IHRoaXMuX2VsZW1lbnQ7XHJcbiAgICAgICAgICAgICAgICBjYXB0dXJpbmdFbGVtZW50LnNldFBvaW50ZXJDYXB0dXJlKGV2ZW50LnBvaW50ZXJJZCk7XHJcbiAgICAgICAgICAgICAgICB0aGlzLl9lbGVtZW50LmFkZEV2ZW50TGlzdGVuZXIodGhpcy5fcmF3VXBkYXRlcyA/ICdwb2ludGVycmF3dXBkYXRlJyA6ICdwb2ludGVybW92ZScsIHRoaXMuX21vdmUpO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5fZWxlbWVudC5hZGRFdmVudExpc3RlbmVyKCdwb2ludGVydXAnLCB0aGlzLl9wb2ludGVyRW5kKTtcclxuICAgICAgICAgICAgICAgIHRoaXMuX2VsZW1lbnQuYWRkRXZlbnRMaXN0ZW5lcigncG9pbnRlcmNhbmNlbCcsIHRoaXMuX3BvaW50ZXJFbmQpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgLy8gTW91c2VFdmVudFxyXG4gICAgICAgICAgICAgICAgd2luZG93LmFkZEV2ZW50TGlzdGVuZXIoJ21vdXNlbW92ZScsIHRoaXMuX21vdmUpO1xyXG4gICAgICAgICAgICAgICAgd2luZG93LmFkZEV2ZW50TGlzdGVuZXIoJ21vdXNldXAnLCB0aGlzLl9wb2ludGVyRW5kKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH07XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogTGlzdGVuZXIgZm9yIHRvdWNoc3RhcnQuXHJcbiAgICAgICAgICogT25seSB1c2VkIGlmIHRoZSBicm93c2VyIGRvZXNuJ3Qgc3VwcG9ydCBwb2ludGVyIGV2ZW50cy5cclxuICAgICAgICAgKi9cclxuICAgICAgICB0aGlzLl90b3VjaFN0YXJ0ID0gKGV2ZW50KSA9PiB7XHJcbiAgICAgICAgICAgIGZvciAoY29uc3QgdG91Y2ggb2YgQXJyYXkuZnJvbShldmVudC5jaGFuZ2VkVG91Y2hlcykpIHtcclxuICAgICAgICAgICAgICAgIHRoaXMuX3RyaWdnZXJQb2ludGVyU3RhcnQobmV3IFBvaW50ZXIodG91Y2gpLCBldmVudCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9O1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIExpc3RlbmVyIGZvciBwb2ludGVyL21vdXNlL3RvdWNoIG1vdmUgZXZlbnRzLlxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIHRoaXMuX21vdmUgPSAoZXZlbnQpID0+IHtcclxuICAgICAgICAgICAgY29uc3QgcHJldmlvdXNQb2ludGVycyA9IHRoaXMuY3VycmVudFBvaW50ZXJzLnNsaWNlKCk7XHJcbiAgICAgICAgICAgIGNvbnN0IGNoYW5nZWRQb2ludGVycyA9ICdjaGFuZ2VkVG91Y2hlcycgaW4gZXZlbnQgLy8gU2hvcnRjdXQgZm9yICdpcyB0b3VjaCBldmVudCcuXHJcbiAgICAgICAgICAgICAgICA/IEFycmF5LmZyb20oZXZlbnQuY2hhbmdlZFRvdWNoZXMpLm1hcCgodCkgPT4gbmV3IFBvaW50ZXIodCkpXHJcbiAgICAgICAgICAgICAgICA6IFtuZXcgUG9pbnRlcihldmVudCldO1xyXG4gICAgICAgICAgICBjb25zdCB0cmFja2VkQ2hhbmdlZFBvaW50ZXJzID0gW107XHJcbiAgICAgICAgICAgIGZvciAoY29uc3QgcG9pbnRlciBvZiBjaGFuZ2VkUG9pbnRlcnMpIHtcclxuICAgICAgICAgICAgICAgIGNvbnN0IGluZGV4ID0gdGhpcy5jdXJyZW50UG9pbnRlcnMuZmluZEluZGV4KChwKSA9PiBwLmlkID09PSBwb2ludGVyLmlkKTtcclxuICAgICAgICAgICAgICAgIGlmIChpbmRleCA9PT0gLTEpXHJcbiAgICAgICAgICAgICAgICAgICAgY29udGludWU7IC8vIE5vdCBhIHBvaW50ZXIgd2UncmUgdHJhY2tpbmdcclxuICAgICAgICAgICAgICAgIHRyYWNrZWRDaGFuZ2VkUG9pbnRlcnMucHVzaChwb2ludGVyKTtcclxuICAgICAgICAgICAgICAgIHRoaXMuY3VycmVudFBvaW50ZXJzW2luZGV4XSA9IHBvaW50ZXI7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgaWYgKHRyYWNrZWRDaGFuZ2VkUG9pbnRlcnMubGVuZ3RoID09PSAwKVxyXG4gICAgICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgICAgICB0aGlzLl9tb3ZlQ2FsbGJhY2socHJldmlvdXNQb2ludGVycywgdHJhY2tlZENoYW5nZWRQb2ludGVycywgZXZlbnQpO1xyXG4gICAgICAgIH07XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogQ2FsbCB0aGUgZW5kIGNhbGxiYWNrIGZvciB0aGlzIHBvaW50ZXIuXHJcbiAgICAgICAgICpcclxuICAgICAgICAgKiBAcGFyYW0gcG9pbnRlciBQb2ludGVyXHJcbiAgICAgICAgICogQHBhcmFtIGV2ZW50IFJlbGF0ZWQgZXZlbnRcclxuICAgICAgICAgKi9cclxuICAgICAgICB0aGlzLl90cmlnZ2VyUG9pbnRlckVuZCA9IChwb2ludGVyLCBldmVudCkgPT4ge1xyXG4gICAgICAgICAgICBjb25zdCBpbmRleCA9IHRoaXMuY3VycmVudFBvaW50ZXJzLmZpbmRJbmRleCgocCkgPT4gcC5pZCA9PT0gcG9pbnRlci5pZCk7XHJcbiAgICAgICAgICAgIC8vIE5vdCBhIHBvaW50ZXIgd2UncmUgaW50ZXJlc3RlZCBpbj9cclxuICAgICAgICAgICAgaWYgKGluZGV4ID09PSAtMSlcclxuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgICAgICAgICAgdGhpcy5jdXJyZW50UG9pbnRlcnMuc3BsaWNlKGluZGV4LCAxKTtcclxuICAgICAgICAgICAgdGhpcy5zdGFydFBvaW50ZXJzLnNwbGljZShpbmRleCwgMSk7XHJcbiAgICAgICAgICAgIGNvbnN0IGNhbmNlbGxlZCA9IGV2ZW50LnR5cGUgPT09ICd0b3VjaGNhbmNlbCcgfHwgZXZlbnQudHlwZSA9PT0gJ3BvaW50ZXJjYW5jZWwnO1xyXG4gICAgICAgICAgICB0aGlzLl9lbmRDYWxsYmFjayhwb2ludGVyLCBldmVudCwgY2FuY2VsbGVkKTtcclxuICAgICAgICAgICAgcmV0dXJuIHRydWU7XHJcbiAgICAgICAgfTtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBMaXN0ZW5lciBmb3IgbW91c2UvcG9pbnRlciBlbmRzLlxyXG4gICAgICAgICAqXHJcbiAgICAgICAgICogQHBhcmFtIGV2ZW50IFRoaXMgd2lsbCBvbmx5IGJlIGEgTW91c2VFdmVudCBpZiB0aGUgYnJvd3NlciBkb2Vzbid0IHN1cHBvcnQgcG9pbnRlciBldmVudHMuXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgdGhpcy5fcG9pbnRlckVuZCA9IChldmVudCkgPT4ge1xyXG4gICAgICAgICAgICBpZiAoIXRoaXMuX3RyaWdnZXJQb2ludGVyRW5kKG5ldyBQb2ludGVyKGV2ZW50KSwgZXZlbnQpKVxyXG4gICAgICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgICAgICBpZiAoaXNQb2ludGVyRXZlbnQoZXZlbnQpKSB7XHJcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5jdXJyZW50UG9pbnRlcnMubGVuZ3RoKVxyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICAgICAgICAgIHRoaXMuX2VsZW1lbnQucmVtb3ZlRXZlbnRMaXN0ZW5lcih0aGlzLl9yYXdVcGRhdGVzID8gJ3BvaW50ZXJyYXd1cGRhdGUnIDogJ3BvaW50ZXJtb3ZlJywgdGhpcy5fbW92ZSk7XHJcbiAgICAgICAgICAgICAgICB0aGlzLl9lbGVtZW50LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ3BvaW50ZXJ1cCcsIHRoaXMuX3BvaW50ZXJFbmQpO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5fZWxlbWVudC5yZW1vdmVFdmVudExpc3RlbmVyKCdwb2ludGVyY2FuY2VsJywgdGhpcy5fcG9pbnRlckVuZCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAvLyBNb3VzZUV2ZW50XHJcbiAgICAgICAgICAgICAgICB3aW5kb3cucmVtb3ZlRXZlbnRMaXN0ZW5lcignbW91c2Vtb3ZlJywgdGhpcy5fbW92ZSk7XHJcbiAgICAgICAgICAgICAgICB3aW5kb3cucmVtb3ZlRXZlbnRMaXN0ZW5lcignbW91c2V1cCcsIHRoaXMuX3BvaW50ZXJFbmQpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfTtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBMaXN0ZW5lciBmb3IgdG91Y2hlbmQuXHJcbiAgICAgICAgICogT25seSB1c2VkIGlmIHRoZSBicm93c2VyIGRvZXNuJ3Qgc3VwcG9ydCBwb2ludGVyIGV2ZW50cy5cclxuICAgICAgICAgKi9cclxuICAgICAgICB0aGlzLl90b3VjaEVuZCA9IChldmVudCkgPT4ge1xyXG4gICAgICAgICAgICBmb3IgKGNvbnN0IHRvdWNoIG9mIEFycmF5LmZyb20oZXZlbnQuY2hhbmdlZFRvdWNoZXMpKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLl90cmlnZ2VyUG9pbnRlckVuZChuZXcgUG9pbnRlcih0b3VjaCksIGV2ZW50KTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH07XHJcbiAgICAgICAgdGhpcy5fc3RhcnRDYWxsYmFjayA9IHN0YXJ0O1xyXG4gICAgICAgIHRoaXMuX21vdmVDYWxsYmFjayA9IG1vdmU7XHJcbiAgICAgICAgdGhpcy5fZW5kQ2FsbGJhY2sgPSBlbmQ7XHJcbiAgICAgICAgdGhpcy5fcmF3VXBkYXRlcyA9IHJhd1VwZGF0ZXMgJiYgJ29ucG9pbnRlcnJhd3VwZGF0ZScgaW4gd2luZG93O1xyXG4gICAgICAgIC8vIEFkZCBsaXN0ZW5lcnNcclxuICAgICAgICBpZiAoc2VsZi5Qb2ludGVyRXZlbnQpIHtcclxuICAgICAgICAgICAgdGhpcy5fZWxlbWVudC5hZGRFdmVudExpc3RlbmVyKCdwb2ludGVyZG93bicsIHRoaXMuX3BvaW50ZXJTdGFydCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICB0aGlzLl9lbGVtZW50LmFkZEV2ZW50TGlzdGVuZXIoJ21vdXNlZG93bicsIHRoaXMuX3BvaW50ZXJTdGFydCk7XHJcbiAgICAgICAgICAgIHRoaXMuX2VsZW1lbnQuYWRkRXZlbnRMaXN0ZW5lcigndG91Y2hzdGFydCcsIHRoaXMuX3RvdWNoU3RhcnQpO1xyXG4gICAgICAgICAgICB0aGlzLl9lbGVtZW50LmFkZEV2ZW50TGlzdGVuZXIoJ3RvdWNobW92ZScsIHRoaXMuX21vdmUpO1xyXG4gICAgICAgICAgICB0aGlzLl9lbGVtZW50LmFkZEV2ZW50TGlzdGVuZXIoJ3RvdWNoZW5kJywgdGhpcy5fdG91Y2hFbmQpO1xyXG4gICAgICAgICAgICB0aGlzLl9lbGVtZW50LmFkZEV2ZW50TGlzdGVuZXIoJ3RvdWNoY2FuY2VsJywgdGhpcy5fdG91Y2hFbmQpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogUmVtb3ZlIGFsbCBsaXN0ZW5lcnMuXHJcbiAgICAgKi9cclxuICAgIHN0b3AoKSB7XHJcbiAgICAgICAgdGhpcy5fZWxlbWVudC5yZW1vdmVFdmVudExpc3RlbmVyKCdwb2ludGVyZG93bicsIHRoaXMuX3BvaW50ZXJTdGFydCk7XHJcbiAgICAgICAgdGhpcy5fZWxlbWVudC5yZW1vdmVFdmVudExpc3RlbmVyKCdtb3VzZWRvd24nLCB0aGlzLl9wb2ludGVyU3RhcnQpO1xyXG4gICAgICAgIHRoaXMuX2VsZW1lbnQucmVtb3ZlRXZlbnRMaXN0ZW5lcigndG91Y2hzdGFydCcsIHRoaXMuX3RvdWNoU3RhcnQpO1xyXG4gICAgICAgIHRoaXMuX2VsZW1lbnQucmVtb3ZlRXZlbnRMaXN0ZW5lcigndG91Y2htb3ZlJywgdGhpcy5fbW92ZSk7XHJcbiAgICAgICAgdGhpcy5fZWxlbWVudC5yZW1vdmVFdmVudExpc3RlbmVyKCd0b3VjaGVuZCcsIHRoaXMuX3RvdWNoRW5kKTtcclxuICAgICAgICB0aGlzLl9lbGVtZW50LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ3RvdWNoY2FuY2VsJywgdGhpcy5fdG91Y2hFbmQpO1xyXG4gICAgICAgIHRoaXMuX2VsZW1lbnQucmVtb3ZlRXZlbnRMaXN0ZW5lcih0aGlzLl9yYXdVcGRhdGVzID8gJ3BvaW50ZXJyYXd1cGRhdGUnIDogJ3BvaW50ZXJtb3ZlJywgdGhpcy5fbW92ZSk7XHJcbiAgICAgICAgdGhpcy5fZWxlbWVudC5yZW1vdmVFdmVudExpc3RlbmVyKCdwb2ludGVydXAnLCB0aGlzLl9wb2ludGVyRW5kKTtcclxuICAgICAgICB0aGlzLl9lbGVtZW50LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ3BvaW50ZXJjYW5jZWwnLCB0aGlzLl9wb2ludGVyRW5kKTtcclxuICAgICAgICB3aW5kb3cucmVtb3ZlRXZlbnRMaXN0ZW5lcignbW91c2Vtb3ZlJywgdGhpcy5fbW92ZSk7XHJcbiAgICAgICAgd2luZG93LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ21vdXNldXAnLCB0aGlzLl9wb2ludGVyRW5kKTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogQ2FsbCB0aGUgc3RhcnQgY2FsbGJhY2sgZm9yIHRoaXMgcG9pbnRlciwgYW5kIHRyYWNrIGl0IGlmIHRoZSB1c2VyIHdhbnRzLlxyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSBwb2ludGVyIFBvaW50ZXJcclxuICAgICAqIEBwYXJhbSBldmVudCBSZWxhdGVkIGV2ZW50XHJcbiAgICAgKiBAcmV0dXJucyBXaGV0aGVyIHRoZSBwb2ludGVyIGlzIGJlaW5nIHRyYWNrZWQuXHJcbiAgICAgKi9cclxuICAgIF90cmlnZ2VyUG9pbnRlclN0YXJ0KHBvaW50ZXIsIGV2ZW50KSB7XHJcbiAgICAgICAgaWYgKCF0aGlzLl9zdGFydENhbGxiYWNrKHBvaW50ZXIsIGV2ZW50KSlcclxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgICAgIHRoaXMuY3VycmVudFBvaW50ZXJzLnB1c2gocG9pbnRlcik7XHJcbiAgICAgICAgdGhpcy5zdGFydFBvaW50ZXJzLnB1c2gocG9pbnRlcik7XHJcbiAgICAgICAgcmV0dXJuIHRydWU7XHJcbiAgICB9XHJcbn1cblxuZXhwb3J0IGRlZmF1bHQgUG9pbnRlclRyYWNrZXI7XG4iXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/pointer-tracker/dist/PointerTracker.mjs\n");

/***/ }),

/***/ "./src/index.ts":
/*!**********************!*\
  !*** ./src/index.ts ***!
  \**********************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var pointer_tracker__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! pointer-tracker */ \"./node_modules/pointer-tracker/dist/PointerTracker.mjs\");\nvar _a;\n\n// ------------------- Initialise values \n// create variables for accessing HTML elements\nconst dragObject = document.getElementById('drag-object');\nconst dragBoundary = document.getElementById('boundary');\n// size of the draggable object on page load\nlet startWidth = dragObject.offsetWidth;\nlet startHeight = dragObject.offsetHeight;\n// limits for scaling\nconst minHeight = startHeight / 4;\nconst minWidth = startWidth / 4;\nconst maxHeight = startHeight * 4;\nconst maxWidth = startWidth * 4;\n// create global variables\n// offsets of mouse from the top and left sides of teh draggabe object\nvar mouseOffsetX;\nvar mouseOffsetY;\n// distance between two pointers when second is first pressed\nvar startPointerDistance;\n// ------------------- Event handler functions\n// centre draggable div on button press\nfunction handleCentre() {\n    dragObject.style.setProperty(\"transition\", 'left 1s, top 1s');\n    dragObject.style.setProperty('top', `${window.innerHeight / 2 - dragObject.offsetHeight / 2}px`);\n    dragObject.style.setProperty('left', `${window.innerWidth / 2 - dragObject.offsetWidth / 2}px`);\n}\n// activate handleCentre function when centre button is pressed\n(_a = document.getElementById('centre-button')) === null || _a === void 0 ? void 0 : _a.addEventListener('click', handleCentre);\nfunction handleReposition(e) {\n    // stop transisition animations that may have been activated after pressing centre button\n    dragObject.style.setProperty(\"transition\", 'null');\n    // set position of draggable div based on mouse position, and correct for starting mouse offset\n    dragObject.style.setProperty('top', `${e.clientY - mouseOffsetY}px`);\n    dragObject.style.setProperty('left', `${e.clientX - mouseOffsetX}px`);\n}\nfunction handleDragEnd() {\n    // get location of each side of the draggable div, relative to the top and left sides of the window\n    const rect = dragObject.getBoundingClientRect();\n    // out of bounds on left side\n    if (rect.left < 20) {\n        console.log('out of bounds');\n        dragObject === null || dragObject === void 0 ? void 0 : dragObject.style.setProperty('left', '20px');\n    }\n    // out of bounds on top side\n    if (rect.top < 20) {\n        console.log('out of bounds');\n        dragObject === null || dragObject === void 0 ? void 0 : dragObject.style.setProperty('top', '20px');\n    }\n    // out of bounds on right side\n    if (rect.right > window.innerWidth - 20) {\n        console.log('out of bounds');\n        dragObject.style.setProperty('left', `${window.innerWidth - dragObject.offsetWidth - 20}px`);\n    }\n    // out of bounds on bottom side\n    if (rect.bottom > window.innerHeight - 20) {\n        console.log('out of bounds');\n        dragObject.style.setProperty('top', `${window.innerHeight - dragObject.offsetHeight - 20}px`);\n    }\n}\nfunction handleResize(scaleFactor) {\n    // prevent scaling past the drag boundary region\n    let newHeight = Math.min(scaleFactor * startHeight, window.innerHeight - 40);\n    let newWidth = Math.min(scaleFactor * startWidth, window.innerWidth - 40);\n    // when scaling is restricted by the window size, keep the shape square\n    if (window.innerHeight > window.innerWidth) {\n        newHeight = newWidth;\n    }\n    else {\n        newWidth = newHeight;\n    }\n    // prevent scaling past 400% and below 25%\n    if (newHeight < minHeight) {\n        newHeight = minHeight;\n    }\n    if (newHeight > maxHeight) {\n        newHeight = maxHeight;\n    }\n    if (newWidth < minWidth) {\n        newWidth = minWidth;\n    }\n    if (newWidth > maxWidth) {\n        newWidth = maxWidth;\n    }\n    // set CSS properties of the draggable div\n    dragObject.style.setProperty('height', `${newHeight}px`);\n    dragObject.style.setProperty('width', `${newWidth}px`);\n}\n// ------------------- keep element within bounds on window resize\nwindow.addEventListener('resize', () => {\n    // get location of each side of the draggable div, relative to the top and left sides of the window\n    let rect = dragObject.getBoundingClientRect();\n    // only need to check for right and bottom sides, because div is positioned relative to the top and left sides of the window\n    if (rect.right > window.innerWidth) {\n        dragObject === null || dragObject === void 0 ? void 0 : dragObject.style.setProperty('left', `${window.innerWidth - dragObject.offsetWidth - 20}px`);\n    }\n    if (rect.bottom > window.innerHeight) {\n        dragObject === null || dragObject === void 0 ? void 0 : dragObject.style.setProperty('top', `${window.innerHeight - dragObject.offsetHeight - 20}px`);\n    }\n});\nfunction getDistance(a, b) {\n    return Math.sqrt(Math.pow((b.clientX - a.clientX), 2) + Math.pow((b.clientY - a.clientY), 2));\n}\n// ------------------- pointer tracking\n// track pointers on the draggable div\nconst objectTracker = new pointer_tracker__WEBPACK_IMPORTED_MODULE_0__.default(dragObject, {\n    start(_, event) {\n        // only track 1 pointer\n        if (objectTracker.currentPointers.length === 1)\n            return false;\n        // set starting offsets from draggable div top and left edges\n        mouseOffsetX = event.offsetX;\n        mouseOffsetY = event.offsetY;\n        return true;\n    },\n    move(_, __, event) {\n        // reposition div based on the current location of the pointer\n        handleReposition(event);\n    },\n    end() {\n        // check that the div is being dropped in the allowable region\n        handleDragEnd();\n    }\n});\n// track pointers anywhere in the draggable region\nconst screenTracker = new pointer_tracker__WEBPACK_IMPORTED_MODULE_0__.default(dragBoundary, {\n    start(pointer) {\n        // on start, the latest pointer is not yet in the currentPointers array\n        // the currentPointers array length is therefore 1 when the second pointer is introduced\n        if (screenTracker.currentPointers.length === 1) {\n            // get intial distance between the 2 pointers\n            startPointerDistance = getDistance(pointer, screenTracker.currentPointers[0]);\n            // get the size of the draggable div at the start of resizing occuring\n            startHeight = dragObject.offsetHeight;\n            startWidth = dragObject.offsetWidth;\n        }\n        return true;\n    },\n    move() {\n        // once the pointers are moving, both point trackers are in the currentPointers array\n        if (screenTracker.currentPointers.length === 2) {\n            // get current distance between the two touched points\n            const newPointerDistance = getDistance(screenTracker.currentPointers[0], screenTracker.currentPointers[1]);\n            // calculate the scale factor based on the percentage change of the distance between tounched points\n            const scaleFactor = newPointerDistance / startPointerDistance;\n            // resize the elemtn with the calculated scale factor\n            handleResize(scaleFactor);\n        }\n    }\n});\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9kbmQtdHlwZXNjcmlwdC8uL3NyYy9pbmRleC50cz9mZmI0Il0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7OztBQUE2QztBQUU3Qyx5Q0FBeUM7QUFFekMsK0NBQStDO0FBQy9DLE1BQU0sVUFBVSxHQUFHLFFBQVEsQ0FBQyxjQUFjLENBQUMsYUFBYSxDQUFFO0FBQzFELE1BQU0sWUFBWSxHQUFHLFFBQVEsQ0FBQyxjQUFjLENBQUMsVUFBVSxDQUFFO0FBRXpELDRDQUE0QztBQUM1QyxJQUFJLFVBQVUsR0FBRyxVQUFVLENBQUMsV0FBVyxDQUFDO0FBQ3hDLElBQUksV0FBVyxHQUFHLFVBQVUsQ0FBQyxZQUFZLENBQUM7QUFFMUMscUJBQXFCO0FBQ3JCLE1BQU0sU0FBUyxHQUFHLFdBQVcsR0FBRyxDQUFDLENBQUM7QUFDbEMsTUFBTSxRQUFRLEdBQUcsVUFBVSxHQUFHLENBQUMsQ0FBQztBQUNoQyxNQUFNLFNBQVMsR0FBRyxXQUFXLEdBQUcsQ0FBQyxDQUFDO0FBQ2xDLE1BQU0sUUFBUSxHQUFHLFVBQVUsR0FBRyxDQUFDLENBQUM7QUFFaEMsMEJBQTBCO0FBQzFCLHNFQUFzRTtBQUN0RSxJQUFJLFlBQW9CLENBQUM7QUFDekIsSUFBSSxZQUFvQixDQUFDO0FBQ3pCLDZEQUE2RDtBQUM3RCxJQUFJLG9CQUE0QixDQUFDO0FBRWpDLDhDQUE4QztBQUU5Qyx1Q0FBdUM7QUFDdkMsU0FBUyxZQUFZO0lBQ2pCLFVBQVUsQ0FBQyxLQUFLLENBQUMsV0FBVyxDQUFDLFlBQVksRUFBRSxpQkFBaUIsQ0FBQztJQUM3RCxVQUFVLENBQUMsS0FBSyxDQUFDLFdBQVcsQ0FBQyxLQUFLLEVBQUUsR0FBRyxNQUFNLENBQUMsV0FBVyxHQUFHLENBQUMsR0FBRyxVQUFVLENBQUMsWUFBWSxHQUFHLENBQUMsSUFBSSxDQUFDLENBQUM7SUFDakcsVUFBVSxDQUFDLEtBQUssQ0FBQyxXQUFXLENBQUMsTUFBTSxFQUFFLEdBQUcsTUFBTSxDQUFDLFVBQVUsR0FB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QUFXO1NBQ3RDO1FBQ0QsT0FBTyxJQUFJLENBQUM7SUFDaEIsQ0FBQztJQUNELElBQUk7UUFDQSxxRkFBcUY7UUFDckYsSUFBSSxhQUFhLENBQUMsZUFBZSxDQUFDLE1BQU0sS0FBSyxDQUFDLEVBQUU7WUFDNUMsc0RBQXNEO1lBQ3RELE1BQU0sa0JBQWtCLEdBQUcsV0FBVyxDQUFDLGFBQWEsQ0FBQyxlQUFlLENBQUMsQ0FBQyxDQUFDLEVBQUUsYUFBYSxDQUFDLGVBQWUsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDO1lBQzNHLG9HQUFvRztZQUNwRyxNQUFNLFdBQVcsR0FBRyxrQkFBa0IsR0FBRyxvQkFBcUI7WUFDOUQscURBQXFEO1lBQ3JELFlBQVksQ0FBQyxXQUFXLENBQUM7U0FDNUI7SUFDTCxDQUFDO0NBQ0osQ0FBQyIsImZpbGUiOiIuL3NyYy9pbmRleC50cy5qcyIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCBQb2ludGVyVHJhY2tlciBmcm9tICdwb2ludGVyLXRyYWNrZXInO1xuXG4vLyAtLS0tLS0tLS0tLS0tLS0tLS0tIEluaXRpYWxpc2UgdmFsdWVzIFxuXG4vLyBjcmVhdGUgdmFyaWFibGVzIGZvciBhY2Nlc3NpbmcgSFRNTCBlbGVtZW50c1xuY29uc3QgZHJhZ09iamVjdCA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKCdkcmFnLW9iamVjdCcpIVxuY29uc3QgZHJhZ0JvdW5kYXJ5ID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoJ2JvdW5kYXJ5JykhXG5cbi8vIHNpemUgb2YgdGhlIGRyYWdnYWJsZSBvYmplY3Qgb24gcGFnZSBsb2FkXG5sZXQgc3RhcnRXaWR0aCA9IGRyYWdPYmplY3Qub2Zmc2V0V2lkdGg7XG5sZXQgc3RhcnRIZWlnaHQgPSBkcmFnT2JqZWN0Lm9mZnNldEhlaWdodDtcblxuLy8gbGltaXRzIGZvciBzY2FsaW5nXG5jb25zdCBtaW5IZWlnaHQgPSBzdGFydEhlaWdodCAvIDQ7XG5jb25zdCBtaW5XaWR0aCA9IHN0YXJ0V2lkdGggLyA0O1xuY29uc3QgbWF4SGVpZ2h0ID0gc3RhcnRIZWlnaHQgKiA0O1xuY29uc3QgbWF4V2lkdGggPSBzdGFydFdpZHRoICogNDtcblxuLy8gY3JlYXRlIGdsb2JhbCB2YXJpYWJsZXNcbi8vIG9mZnNldHMgb2YgbW91c2UgZnJvbSB0aGUgdG9wIGFuZCBsZWZ0IHNpZGVzIG9mIHRlaCBkcmFnZ2FiZSBvYmplY3RcbnZhciBtb3VzZU9mZnNldFg6IG51bWJlcjtcbnZhciBtb3VzZU9mZnNldFk6IG51bWJlcjtcbi8vIGRpc3RhbmNlIGJldHdlZW4gdHdvIHBvaW50ZXJzIHdoZW4gc2Vjb25kIGlzIGZpcnN0IHByZXNzZWRcbnZhciBzdGFydFBvaW50ZXJEaXN0YW5jZTogbnVtYmVyO1xuXG4vLyAtLS0tLS0tLS0tLS0tLS0tLS0tIEV2ZW50IGhhbmRsZXIgZnVuY3Rpb25zXG5cbi8vIGNlbnRyZSBkcmFnZ2FibGUgZGl2IG9uIGJ1dHRvbiBwcmVzc1xuZnVuY3Rpb24gaGFuZGxlQ2VudHJlKCkge1xuICAgIGRyYWdPYmplY3Quc3R5bGUuc2V0UHJvcGVydHkoXCJ0cmFuc2l0aW9uXCIsICdsZWZ0IDFzLCB0b3AgMXMnKVxuICAgIGRyYWdPYmplY3Quc3R5bGUuc2V0UHJvcGVydHkoJ3RvcCcsIGAke3dpbmRvdy5pbm5lckhlaWdodCAvIDIgLSBkcmFnT2JqZWN0Lm9mZnNldEhlaWdodCAvIDJ9cHhgKTtcbiAgICBkcmFnT2JqZWN0LnN0eWxlLnNldFByb3BlcnR5KCdsZWZ0JywgYCR7d2luZG93LmlubmVyV2lkdGggLyAyIC0gZHJhZ09iamVjdC5vZmZzZXRXaWR0aCAvIDJ9cHhgKTtcbn1cbi8vIGFjdGl2YXRlIGhhbmRsZUNlbnRyZSBmdW5jdGlvbiB3aGVuIGNlbnRyZSBidXR0b24gaXMgcHJlc3NlZFxuZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoJ2NlbnRyZS1idXR0b24nKT8uYWRkRXZlbnRMaXN0ZW5lcignY2xpY2snLCBoYW5kbGVDZW50cmUpXG5cbmZ1bmN0aW9uIGhhbmRsZVJlcG9zaXRpb24oZTogTW91c2VFdmVudCkge1xuICAgIC8vIHN0b3AgdHJhbnNpc2l0aW9uIGFuaW1hdGlvbnMgdGhhdCBtYXkgaGF2ZSBiZWVuIGFjdGl2YXRlZCBhZnRlciBwcmVzc2luZyBjZW50cmUgYnV0dG9uXG4gICAgZHJhZ09iamVjdC5zdHlsZS5zZXRQcm9wZXJ0eShcInRyYW5zaXRpb25cIiwgJ251bGwnKVxuICAgIC8vIHNldCBwb3NpdGlvbiBvZiBkcmFnZ2FibGUgZGl2IGJhc2VkIG9uIG1vdXNlIHBvc2l0aW9uLCBhbmQgY29ycmVjdCBmb3Igc3RhcnRpbmcgbW91c2Ugb2Zmc2V0XG4gICAgZHJhZ09iamVjdC5zdHlsZS5zZXRQcm9wZXJ0eSgndG9wJywgYCR7ZS5jbGllbnRZIC0gbW91c2VPZmZzZXRZfXB4YCk7XG4gICAgZHJhZ09iamVjdC5zdHlsZS5zZXRQcm9wZXJ0eSgnbGVmdCcsIGAke2UuY2xpZW50WCAtIG1vdXNlT2Zmc2V0WH1weGApO1xufVxuXG5mdW5jdGlvbiBoYW5kbGVEcmFnRW5kKCkge1xuICAgIC8vIGdldCBsb2NhdGlvbiBvZiBlYWNoIHNpZGUgb2YgdGhlIGRyYWdnYWJsZSBkaXYsIHJlbGF0aXZlIHRvIHRoZSB0b3AgYW5kIGxlZnQgc2lkZXMgb2YgdGhlIHdpbmRvd1xuICAgIGNvbnN0IHJlY3QgPSBkcmFnT2JqZWN0LmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuICAgIC8vIG91dCBvZiBib3VuZHMgb24gbGVmdCBzaWRlXG4gICAgaWYgKHJlY3QubGVmdCA8IDIwKSB7XG4gICAgICAgIGNvbnNvbGUubG9nKCdvdXQgb2YgYm91bmRzJylcbiAgICAgICAgZHJhZ09iamVjdD8uc3R5bGUuc2V0UHJvcGVydHkoJ2xlZnQnLCAnMjBweCcpO1xuICAgIH1cbiAgICAvLyBvdXQgb2YgYm91bmRzIG9uIHRvcCBzaWRlXG4gICAgaWYgKHJlY3QudG9wIDwgMjApIHtcbiAgICAgICAgY29uc29sZS5sb2coJ291dCBvZiBib3VuZHMnKVxuICAgICAgICBkcmFnT2JqZWN0Py5zdHlsZS5zZXRQcm9wZXJ0eSgndG9wJywgJzIwcHgnKTtcbiAgICB9XG4gICAgLy8gb3V0IG9mIGJvdW5kcyBvbiByaWdodCBzaWRlXG4gICAgaWYgKHJlY3QucmlnaHQgPiB3aW5kb3cuaW5uZXJXaWR0aCAtIDIwKSB7XG4gICAgICAgIGNvbnNvbGUubG9nKCdvdXQgb2YgYm91bmRzJylcbiAgICAgICAgZHJhZ09iamVjdC5zdHlsZS5zZXRQcm9wZXJ0eSgnbGVmdCcsIGAke3dpbmRvdy5pbm5lcldpZHRoIC0gZHJhZ09iamVjdC5vZmZzZXRXaWR0aCAtIDIwfXB4YCk7XG4gICAgfVxuICAgIC8vIG91dCBvZiBib3VuZHMgb24gYm90dG9tIHNpZGVcbiAgICBpZiAocmVjdC5ib3R0b20gPiB3aW5kb3cuaW5uZXJIZWlnaHQgLSAyMCkge1xuICAgICAgICBjb25zb2xlLmxvZygnb3V0IG9mIGJvdW5kcycpXG4gICAgICAgIGRyYWdPYmplY3Quc3R5bGUuc2V0UHJvcGVydHkoJ3RvcCcsIGAke3dpbmRvdy5pbm5lckhlaWdodCAtIGRyYWdPYmplY3Qub2Zmc2V0SGVpZ2h0IC0gMjB9cHhgKTtcbiAgICB9XG59XG5cbmZ1bmN0aW9uIGhhbmRsZVJlc2l6ZShzY2FsZUZhY3RvcjogbnVtYmVyKSB7XG4gICAgLy8gcHJldmVudCBzY2FsaW5nIHBhc3QgdGhlIGRyYWcgYm91bmRhcnkgcmVnaW9uXG4gICAgbGV0IG5ld0hlaWdodCA9IE1hdGgubWluKHNjYWxlRmFjdG9yICogc3RhcnRIZWlnaHQsIHdpbmRvdy5pbm5lckhlaWdodCAtIDQwKTtcbiAgICBsZXQgbmV3V2lkdGggPSBNYXRoLm1pbihzY2FsZUZhY3RvciAqIHN0YXJ0V2lkdGgsIHdpbmRvdy5pbm5lcldpZHRoIC0gNDApO1xuICAgIC8vIHdoZW4gc2NhbGluZyBpcyByZXN0cmljdGVkIGJ5IHRoZSB3aW5kb3cgc2l6ZSwga2VlcCB0aGUgc2hhcGUgc3F1YXJlXG4gICAgaWYgKHdpbmRvdy5pbm5lckhlaWdodCA+IHdpbmRvdy5pbm5lcldpZHRoKSB7XG4gICAgICAgIG5ld0hlaWdodCA9IG5ld1dpZHRoXG4gICAgfSBlbHNlIHtcbiAgICAgICAgbmV3V2lkdGggPSBuZXdIZWlnaHRcbiAgICB9XG4gICAgLy8gcHJldmVudCBzY2FsaW5nIHBhc3QgNDAwJSBhbmQgYmVsb3cgMjUlXG4gICAgaWYgKG5ld0hlaWdodCA8IG1pbkhlaWdodCkge1xuICAgICAgICBuZXdIZWlnaHQgPSBtaW5IZWlnaHRcbiAgICB9XG4gICAgaWYgKG5ld0hlaWdodCA+IG1heEhlaWdodCkge1xuICAgICAgICBuZXdIZWlnaHQgPSBtYXhIZWlnaHRcbiAgICB9XG4gICAgaWYgKG5ld1dpZHRoIDwgbWluV2lkdGgpIHtcbiAgICAgICAgbmV3V2lkdGggPSBtaW5XaWR0aFxuICAgIH1cbiAgICBpZiAobmV3V2lkdGggPiBtYXhXaWR0aCkge1xuICAgICAgICBuZXdXaWR0aCA9IG1heFdpZHRoXG4gICAgfVxuICAgIC8vIHNldCBDU1MgcHJvcGVydGllcyBvZiB0aGUgZHJhZ2dhYmxlIGRpdlxuICAgIGRyYWdPYmplY3Quc3R5bGUuc2V0UHJvcGVydHkoJ2hlaWdodCcsIGAke25ld0hlaWdodH1weGApXG4gICAgZHJhZ09iamVjdC5zdHlsZS5zZXRQcm9wZXJ0eSgnd2lkdGgnLCBgJHtuZXdXaWR0aH1weGApXG59XG5cbi8vIC0tLS0tLS0tLS0tLS0tLS0tLS0ga2VlcCBlbGVtZW50IHdpdGhpbiBib3VuZHMgb24gd2luZG93IHJlc2l6ZVxud2luZG93LmFkZEV2ZW50TGlzdGVuZXIoJ3Jlc2l6ZScsICgpID0+IHtcbiAgICAvLyBnZXQgbG9jYXRpb24gb2YgZWFjaCBzaWRlIG9mIHRoZSBkcmFnZ2FibGUgZGl2LCByZWxhdGl2ZSB0byB0aGUgdG9wIGFuZCBsZWZ0IHNpZGVzIG9mIHRoZSB3aW5kb3dcbiAgICBsZXQgcmVjdCA9IGRyYWdPYmplY3QuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG4gICAgLy8gb25seSBuZWVkIHRvIGNoZWNrIGZvciByaWdodCBhbmQgYm90dG9tIHNpZGVzLCBiZWNhdXNlIGRpdiBpcyBwb3NpdGlvbmVkIHJlbGF0aXZlIHRvIHRoZSB0b3AgYW5kIGxlZnQgc2lkZXMgb2YgdGhlIHdpbmRvd1xuICAgIGlmIChyZWN0LnJpZ2h0ID4gd2luZG93LmlubmVyV2lkdGgpIHtcbiAgICAgICAgZHJhZ09iamVjdD8uc3R5bGUuc2V0UHJvcGVydHkoJ2xlZnQnLCBgJHt3aW5kb3cuaW5uZXJXaWR0aCAtIGRyYWdPYmplY3Qub2Zmc2V0V2lkdGggLSAyMH1weGApO1xuICAgIH1cbiAgICBpZiAocmVjdC5ib3R0b20gPiB3aW5kb3cuaW5uZXJIZWlnaHQpIHtcbiAgICAgICAgZHJhZ09iamVjdD8uc3R5bGUuc2V0UHJvcGVydHkoJ3RvcCcsIGAke3dpbmRvdy5pbm5lckhlaWdodCAtIGRyYWdPYmplY3Qub2Zmc2V0SGVpZ2h0IC0gMjB9cHhgKTtcbiAgICB9XG59KTtcblxuLy8gLS0tLS0tLS0tLS0tLS0tLS0tLSB1dGlsc1xuXG5pbnRlcmZhY2UgUG9pbnQge1xuICAgIGNsaWVudFg6IG51bWJlcjtcbiAgICBjbGllbnRZOiBudW1iZXI7XG4gIH1cblxuaW50ZXJmYWNlIE1vdXNlRXZlbnQge1xuICAgIGNsaWVudFg6IG51bWJlcjtcbiAgICBjbGllbnRZOiBudW1iZXI7XG4gICAgb2Zmc2V0WDogbnVtYmVyO1xuICAgIG9mZnNldFk6IG51bWJlcjtcbn1cblxuZnVuY3Rpb24gZ2V0RGlzdGFuY2UoYTogUG9pbnQsIGI6IFBvaW50KTogbnVtYmVyIHtcbiAgcmV0dXJuIE1hdGguc3FydCgoYi5jbGllbnRYIC0gYS5jbGllbnRYKSAqKiAyICsgKGIuY2xpZW50WSAtIGEuY2xpZW50WSkgKiogMik7XG59XG5cbi8vIC0tLS0tLS0tLS0tLS0tLS0tLS0gcG9pbnRlciB0cmFja2luZ1xuXG4vLyB0cmFjayBwb2ludGVycyBvbiB0aGUgZHJhZ2dhYmxlIGRpdlxuY29uc3Qgb2JqZWN0VHJhY2tlciA9IG5ldyBQb2ludGVyVHJhY2tlcihkcmFnT2JqZWN0LCB7XG4gICAgc3RhcnQoXywgZXZlbnQ6IGFueSkge1xuICAgICAgICAvLyBvbmx5IHRyYWNrIDEgcG9pbnRlclxuICAgICAgICBpZiAob2JqZWN0VHJhY2tlci5jdXJyZW50UG9pbnRlcnMubGVuZ3RoID09PSAxKSByZXR1cm4gZmFsc2U7XG4gICAgICAgIC8vIHNldCBzdGFydGluZyBvZmZzZXRzIGZyb20gZHJhZ2dhYmxlIGRpdiB0b3AgYW5kIGxlZnQgZWRnZXNcbiAgICAgICAgbW91c2VPZmZzZXRYID0gZXZlbnQub2Zmc2V0WDtcbiAgICAgICAgbW91c2VPZmZzZXRZID0gZXZlbnQub2Zmc2V0WTtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfSxcbiAgICBtb3ZlKF8sX18sZXZlbnQ6IGFueSkge1xuICAgICAgICAvLyByZXBvc2l0aW9uIGRpdiBiYXNlZCBvbiB0aGUgY3VycmVudCBsb2NhdGlvbiBvZiB0aGUgcG9pbnRlclxuICAgICAgICBoYW5kbGVSZXBvc2l0aW9uKGV2ZW50KVxuICAgIH0sXG4gICAgZW5kKCkge1xuICAgICAgICAvLyBjaGVjayB0aGF0IHRoZSBkaXYgaXMgYmVpbmcgZHJvcHBlZCBpbiB0aGUgYWxsb3dhYmxlIHJlZ2lvblxuICAgICAgICBoYW5kbGVEcmFnRW5kKClcbiAgICB9XG59KTtcblxuLy8gdHJhY2sgcG9pbnRlcnMgYW55d2hlcmUgaW4gdGhlIGRyYWdnYWJsZSByZWdpb25cbmNvbnN0IHNjcmVlblRyYWNrZXIgPSBuZXcgUG9pbnRlclRyYWNrZXIoZHJhZ0JvdW5kYXJ5LCB7XG4gICAgc3RhcnQocG9pbnRlcjogUG9pbnQpIHtcbiAgICAgICAgLy8gb24gc3RhcnQsIHRoZSBsYXRlc3QgcG9pbnRlciBpcyBub3QgeWV0IGluIHRoZSBjdXJyZW50UG9pbnRlcnMgYXJyYXlcbiAgICAgICAgLy8gdGhlIGN1cnJlbnRQb2ludGVycyBhcnJheSBsZW5ndGggaXMgdGhlcmVmb3JlIDEgd2hlbiB0aGUgc2Vjb25kIHBvaW50ZXIgaXMgaW50cm9kdWNlZFxuICAgICAgICBpZiAoc2NyZWVuVHJhY2tlci5jdXJyZW50UG9pbnRlcnMubGVuZ3RoID09PSAxKSB7XG4gICAgICAgICAgICAvLyBnZXQgaW50aWFsIGRpc3RhbmNlIGJldHdlZW4gdGhlIDIgcG9pbnRlcnNcbiAgICAgICAgICAgIHN0YXJ0UG9pbnRlckRpc3RhbmNlID0gZ2V0RGlzdGFuY2UocG9pbnRlciwgc2NyZWVuVHJhY2tlci5jdXJyZW50UG9pbnRlcnNbMF0pO1xuICAgICAgICAgICAgLy8gZ2V0IHRoZSBzaXplIG9mIHRoZSBkcmFnZ2FibGUgZGl2IGF0IHRoZSBzdGFydCBvZiByZXNpemluZyBvY2N1cmluZ1xuICAgICAgICAgICAgc3RhcnRIZWlnaHQgPSBkcmFnT2JqZWN0Lm9mZnNldEhlaWdodFxuICAgICAgICAgICAgc3RhcnRXaWR0aCA9IGRyYWdPYmplY3Qub2Zmc2V0V2lkdGhcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9LFxuICAgIG1vdmUoKSB7XG4gICAgICAgIC8vIG9uY2UgdGhlIHBvaW50ZXJzIGFyZSBtb3ZpbmcsIGJvdGggcG9pbnQgdHJhY2tlcnMgYXJlIGluIHRoZSBjdXJyZW50UG9pbnRlcnMgYXJyYXlcbiAgICAgICAgaWYgKHNjcmVlblRyYWNrZXIuY3VycmVudFBvaW50ZXJzLmxlbmd0aCA9PT0gMikge1xuICAgICAgICAgICAgLy8gZ2V0IGN1cnJlbnQgZGlzdGFuY2UgYmV0d2VlbiB0aGUgdHdvIHRvdWNoZWQgcG9pbnRzXG4gICAgICAgICAgICBjb25zdCBuZXdQb2ludGVyRGlzdGFuY2UgPSBnZXREaXN0YW5jZShzY3JlZW5UcmFja2VyLmN1cnJlbnRQb2ludGVyc1swXSwgc2NyZWVuVHJhY2tlci5jdXJyZW50UG9pbnRlcnNbMV0pO1xuICAgICAgICAgICAgLy8gY2FsY3VsYXRlIHRoZSBzY2FsZSBmYWN0b3IgYmFzZWQgb24gdGhlIHBlcmNlbnRhZ2UgY2hhbmdlIG9mIHRoZSBkaXN0YW5jZSBiZXR3ZWVuIHRvdW5jaGVkIHBvaW50c1xuICAgICAgICAgICAgY29uc3Qgc2NhbGVGYWN0b3IgPSBuZXdQb2ludGVyRGlzdGFuY2UgLyBzdGFydFBvaW50ZXJEaXN0YW5jZSFcbiAgICAgICAgICAgIC8vIHJlc2l6ZSB0aGUgZWxlbXRuIHdpdGggdGhlIGNhbGN1bGF0ZWQgc2NhbGUgZmFjdG9yXG4gICAgICAgICAgICBoYW5kbGVSZXNpemUoc2NhbGVGYWN0b3IpXG4gICAgICAgIH1cbiAgICB9XG59KSJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./src/index.ts\n");

/***/ })

/******/ 	});
/************************************************************************/
/******/ 	// The module cache
/******/ 	var __webpack_module_cache__ = {};
/******/ 	
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/ 		// Check if module is in cache
/******/ 		var cachedModule = __webpack_module_cache__[moduleId];
/******/ 		if (cachedModule !== undefined) {
/******/ 			return cachedModule.exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = __webpack_module_cache__[moduleId] = {
/******/ 			// no module.id needed
/******/ 			// no module.loaded needed
/******/ 			exports: {}
/******/ 		};
/******/ 	
/******/ 		// Execute the module function
/******/ 		__webpack_modules__[moduleId](module, module.exports, __webpack_require__);
/******/ 	
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/ 	
/************************************************************************/
/******/ 	/* webpack/runtime/define property getters */
/******/ 	(() => {
/******/ 		// define getter functions for harmony exports
/******/ 		__webpack_require__.d = (exports, definition) => {
/******/ 			for(var key in definition) {
/******/ 				if(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {
/******/ 					Object.defineProperty(exports, key, { enumerable: true, get: definition[key] });
/******/ 				}
/******/ 			}
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/hasOwnProperty shorthand */
/******/ 	(() => {
/******/ 		__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/make namespace object */
/******/ 	(() => {
/******/ 		// define __esModule on exports
/******/ 		__webpack_require__.r = (exports) => {
/******/ 			if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 				Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 			}
/******/ 			Object.defineProperty(exports, '__esModule', { value: true });
/******/ 		};
/******/ 	})();
/******/ 	
/************************************************************************/
/******/ 	
/******/ 	// startup
/******/ 	// Load entry module and return exports
/******/ 	// This entry module can't be inlined because the eval-source-map devtool is used.
/******/ 	var __webpack_exports__ = __webpack_require__("./src/index.ts");
/******/ 	
/******/ })()
;